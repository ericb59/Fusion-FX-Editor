<!DOCTYPE html><html lang="fr"><head>  <meta charset="UTF-8" />  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Fusion FX! Editor </title>  <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">  <style>    body {      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;      background-color: #1a1a1a;      color: #e5e5e5;      font-size: 14px;      margin: 0;      min-height: 100vh;      display: flex;      flex-direction: column;    }    .page-container {      width: 100%;      max-width: 1400px;      margin: 0 auto;      display: flex;      flex-direction: column;      flex: 1;    }    .main-content {      display: grid;      grid-template-columns: 300px 1fr;      gap: 10px;      padding: 10px;    }    .left-panel {      display: flex;      flex-direction: column;      gap: 10px;    }    .panel-section {      background: rgba(45, 45, 45, 0.8);      backdrop-filter: blur(20px);      border: 1px solid #454545;      border-radius: 8px;      padding: 12px;    }    .editor-section {      display: flex;      flex-direction: column;      gap: 10px;    }    .canvas-container {      background: #2a2a2a;      border-radius: 8px;      padding: 15px;      border: 1px solid #454545;    }    #editorCanvas {      display: block;      background: #2a2a2a;      cursor: crosshair;      border: 2px solid #454545;      border-radius: 8px;      touch-action: none;      image-rendering: pixelated;    }.btn {  display: inline-flex;  align-items: center;  gap: 6px;  background: #4b5563;  color: white;  border: 1px solid #6b7280;  padding: 8px 12px;  border-radius: 6px;  font-size: 14px;  cursor: pointer;  position: relative;  transition: background-color 0.1s ease;}.btn:hover {  background: #6b7280;}.btn:active {  background: #374151;  transform: translateY(1px);}.btn-primary {  background: #6366f1;  border-color: #4f46e5;}.btn-primary:hover {  background: #4f46e5;}.btn-danger {  background: #ef4444;  border-color: #dc2626;}.btn-danger:hover {  background: #dc2626;}/* Tooltips séparés des hovers */[data-tooltip] {  position: relative;}[data-tooltip]:before {  content: attr(data-tooltip);  position: absolute;  bottom: 100%;  left: 50%;  transform: translateX(-50%);  margin-bottom: 8px;  padding: 6px 10px;  border-radius: 6px;  background: #1f2937;  color: white;  font-size: 12px;  white-space: nowrap;  opacity: 0;  visibility: hidden;  transition: opacity 0.2s ease, visibility 0.2s ease;  transition-delay: 0.5s;  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);  z-index: 10;}[data-tooltip]:after {  content: '';  position: absolute;  bottom: 100%;  left: 50%;  transform: translateX(-50%);  border: 6px solid transparent;  border-top-color: #1f2937;  margin-bottom: -4px;  opacity: 0;  visibility: hidden;  transition: opacity 0.2s ease, visibility 0.2s ease;  transition-delay: 0.5s;}[data-tooltip]:hover:before,[data-tooltip]:hover:after {  opacity: 0.90;  visibility: visible;}    .piano-container {      transition: height 0.3s ease;      overflow: hidden;    }    .piano-container.collapsed {      height: 48px !important;    }    .piano-header {      display: flex;      justify-content: space-between;      align-items: center;      padding: 12px;      cursor: pointer;      height: 48px;      box-sizing: border-box;      margin-top: -5px;    }    .piano-content {      padding: 12px;    }  /* CSS amélioré pour les touches de piano *//* CSS amélioré pour les touches de piano avec plus de largeur */.piano-keys {  display: flex;  gap: 2px;  margin-top: 10px;  position: relative;  height: 70px;  width: 100%; /* Utilise toute la largeur disponible */  justify-content: center; /* Centre les touches */}/* Style de base pour toutes les touches */.piano-keys button {  position: relative;  width: 34px; /* Touches plus larges */  height: 70px;  background: linear-gradient(to bottom, #f0f0f0 0%, #d0d0d0 100%);  color: #333;  border: 1px solid #888;  border-radius: 0 0 4px 4px;  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.3);  cursor: pointer;  transition: all 0.1s;  z-index: 1;  font-weight: bold;}/* Effet au survol */.piano-keys button:hover {  background: linear-gradient(to bottom, #fff 0%, #e8e8e8 100%);}/* Effet lorsqu'on appuie */.piano-keys button:active {  background: linear-gradient(to bottom, #e0e0e0 0%, #b0b0b0 100%);  transform: translateY(2px);  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);}/* Style pour les touches noires */.piano-keys button.black {  background: linear-gradient(to bottom, #333 0%, #000 100%);  color: #eee;  height: 45px;  width: 22px; /* Touches noires plus larges */  margin-left: -11px; /* Ajustement du décalage */  margin-right: -11px; /* Ajustement du décalage */  z-index: 2;  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);}/* Effet au survol pour les touches noires */.piano-keys button.black:hover {  background: linear-gradient(to bottom, #444 0%, #111 100%);}/* Effet lorsqu'on appuie sur les touches noires */.piano-keys button.black:active {  background: linear-gradient(to bottom, #222 0%, #000 100%);  transform: translateY(2px);  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);}/* Adaptations pour le thème sombre */.piano-container {  background: rgba(40, 40, 40, 0.8);}/* Version sombre des touches */.dark .piano-keys button {  background: linear-gradient(to bottom, #555 0%, #444 100%);  color: #ddd;  border: 1px solid #666;}.dark .piano-keys button:hover {  background: linear-gradient(to bottom, #666 0%, #555 100%);}.dark .piano-keys button:active {  background: linear-gradient(to bottom, #444 0%, #333 100%);}.dark .piano-keys button.black {  background: linear-gradient(to bottom, #222 0%, #000 100%);  color: #999;  border: 1px solid #000;}.dark .piano-keys button.black:hover {  background: linear-gradient(to bottom, #333 0%, #111 100%);}.dark .piano-keys button.black:active {  background: linear-gradient(to bottom, #111 0%, #000 100%);} .no-spin::-webkit-inner-spin-button,    .no-spin::-webkit-outer-spin-button {      -webkit-appearance: none;      margin: 0;    }    .no-spin {      -moz-appearance: textfield;    }    .btn-stepper-minus, .btn-stepper-plus {      cursor: pointer;      user-select: none;    }    .btn-stepper-minus:hover, .btn-stepper-plus:hover {      background-color: #4B5563;    }    .btn-stepper-minus:active, .btn-stepper-plus:active {      background-color: #374151;    }/* -- */    #playIndicator {      width: 100%;      height: 20px;      background: #2a2a2a;      border-radius: 4px;      overflow: hidden;      position: relative;    }    #progressBar {      height: 100%;      width: 0%;      background: #6366f1;      transition: width 0.05s linear;    }    .legend span {      display: inline-block;      width: 20px;      height: 12px;      margin-right: 5px;      vertical-align: middle;      border: 1px solid #666;      border-radius: 2px;    }      /* Modal styles */    .modal {        position: fixed;        inset: 0;        background: rgba(0, 0, 0, 0.5);        display: flex;        align-items: flex-start;        justify-content: center;        padding: 20px;        z-index: 1000;    }    .modal-content {        background: #2a2a2a;        border-radius: 8px;        padding: 20px;        max-width: 600px;        width: 90%;        position: relative;  /* Ajout des propriétés pour le défilement */  max-height: calc(100vh - 40px); /* Hauteur max = hauteur viewport - padding */  overflow-y: auto;  /* Style de la barre de défilement */  scrollbar-width: thin; /* Firefox */  scrollbar-color: #666 #2a2a2a; /* Firefox */}    /* Style de la barre de défilement pour Webkit (Chrome, Safari, etc.) */.modal-content::-webkit-scrollbar {  width: 8px;}.modal-content::-webkit-scrollbar-track {  background: #2a2a2a;  border-radius: 4px;}.modal-content::-webkit-scrollbar-thumb {  background: #666;  border-radius: 4px;}.modal-content::-webkit-scrollbar-thumb:hover {  background: #888;}.close-modal {        position: absolute;        right: 15px;        top: 15px;        background: none;        border: none;        color: #888;        font-size: 24px;        cursor: pointer;  z-index: 2; /* S'assurer que le bouton reste au-dessus du contenu */}    .hidden {        display: none;    }  /* Welcome Modale *//* Style de base pour la modal */.welcome-modal {  position: fixed;  inset: 0;  z-index: 1000;  display: flex;  align-items: center;  justify-content: center;  background-color: rgba(0, 0, 0, 0.5);  backdrop-filter: blur(4px);  opacity: 0;  transition: opacity 0.3s ease;}/* Animation du background animé */@keyframes gradientBG {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* Animation heartbeat pour le glow */@keyframes heartbeat {  0%, 100% {    box-shadow: 0 0 15px 3px rgba(79, 70, 229, 0.7);  }  50% {    box-shadow: 0 0 30px 6px rgba(79, 70, 229, 1);  }}/* Contenu de la modal */.modal-content-welcome {  background: linear-gradient(135deg, rgba(67, 66, 202, 0.95) 0%, rgba(199, 70, 249, 0.95) 100%);  background-size: 200% 200%;  animation: gradientBG 10s ease infinite, heartbeat 1.5s ease-in-out infinite;  position: relative;  max-width: 32rem;  margin: 1rem;  padding: 2rem; /* Espace intérieur pour éviter d'être collé aux bords */  border-radius: 1rem;  border: 2px solid transparent; /* Base pour le glow */  transform: scale(0.95);  opacity: 0;  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);}/* Etat actif de la modal */.welcome-modal.active {  opacity: 1;}.welcome-modal.active .modal-content-welcome {  transform: scale(1);  opacity: 1;}/* Animation de sortie */.welcome-modal.closing {  opacity: 0;}.welcome-modal.closing .modal-content-welcome {  transform: scale(0.95);  opacity: 0;}/* Reste des styles pour les boutons et autres éléments */.modal-icon {  animation: float 6s ease-in-out infinite;}.modal-btn {  position: relative;  overflow: hidden;  transition: all 0.3s ease;}.modal-btn:hover {  transform: translateY(-1px);}.modal-btn:active {  transform: translateY(1px);}.feature-list li {  transition: transform 0.2s ease;}.feature-list li:hover {  transform: translateX(5px);}.feature-dot {  display: inline-block;  width: 8px;  height: 8px;  margin-right: 8px;  background-color: rgba(99, 102, 241, 0.6);  border-radius: 50%;  transition: all 0.2s ease;}.feature-list li:hover .feature-dot {  transform: scale(1.2);  background-color: rgba(99, 102, 241, 1);}.close-btn {  position: absolute;  top: 1rem;  right: 1rem;  padding: 0.5rem;  color: rgba(255, 255, 255, 0.6);  transition: all 0.2s ease;}.close-btn:hover {  color: rgba(255, 255, 255, 1);  transform: rotate(90deg);}.modal-content-welcome button.modal-btn {  padding: 8px 16px;  border-radius: 6px;  font-weight: 500;  transition: all 0.2s ease;  border: 1px solid rgba(255, 255, 255, 0.1);  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);}.modal-content-welcome button.modal-btn:hover {  transform: translateY(-1px);  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);}.modal-content-welcome button.modal-btn:active {  transform: translateY(1px);  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);}.modal-content-welcome button.modal-btn.primary {  background: rgb(99, 102, 241);  color: white;  border: 1px solid rgb(79, 70, 229);}.modal-content-welcome button.modal-btn.primary:hover {  background: rgb(79, 70, 229);}.modal-content-welcome button.modal-btn.secondary {  background: rgba(255, 255, 255, 0.1);  color: rgba(255, 255, 255, 0.9);  backdrop-filter: blur(4px);}.modal-content-welcome button.modal-btn.secondary:hover {  background: rgba(255, 255, 255, 0.2);} /* Styles pour les sliders horizontaux */   .horizontal-sliders-container {    padding: 10px 0;    display: flex;    flex-direction: column;    gap: 4px;  }    .horizontal-slider {    width: 100%;    margin-bottom: 2px;  }    .horizontal-slider label, .horizontal-slider .value {    font-size: 12px;    color: #9ca3af;  }    .horizontal-slider input[type="range"] {    appearance: none;    -webkit-appearance: none;    width: 100%;    height: 6px;    background: #4b5563;    border-radius: 3px;    outline: none;    margin-top: 6px;  }    .horizontal-slider input[type="range"]::-webkit-slider-thumb {    -webkit-appearance: none;    appearance: none;    width: 16px;    height: 16px;    background: #6366f1;    border-radius: 50%;    cursor: pointer;  }    .horizontal-slider input[type="range"]::-moz-range-thumb {    width: 16px;    height: 16px;    background: #6366f1;    border-radius: 50%;    cursor: pointer;    border: none;  }    .horizontal-slider input[type="range"]::-webkit-slider-runnable-track {    background: transparent;  }    .horizontal-slider input[type="range"]::-moz-range-track {    background: transparent;  }    /* Suppression des anciens styles pour les sliders verticaux */  .vertical-slider-container {    display: none;  }/* Styles pour les sliders verticaux */  .vertical-slider-container {    display: flex;    align-items: center;    justify-content: space-around;    padding: 20px 0;  }  .vertical-slider {    display: flex;    flex-direction: column;    align-items: center;    gap: 10px;  }  .vertical-slider input[type="range"] {    appearance: none;    height: 150px;    width: 6px;    background: #4b5563;    border-radius: 3px;    outline: none;    writing-mode: bt-lr; /* IE */    -webkit-appearance: slider-vertical; /* WebKit */  }  .vertical-slider input[type="range"]::-webkit-slider-thumb {    -webkit-appearance: none;    appearance: none;    width: 16px;    height: 16px;    background: #6366f1;    border-radius: 50%;    cursor: pointer;  }  .vertical-slider input[type="range"]::-moz-range-thumb {    width: 16px;    height: 16px;    background: #6366f1;    border-radius: 50%;    cursor: pointer;    border: none;  }  .vertical-slider input[type="range"]::-webkit-slider-runnable-track {    background: transparent;  }  .vertical-slider input[type="range"]::-moz-range-track {    background: transparent;  }  .vertical-slider label {    text-align: center;    font-size: 12px;    color: #9ca3af;  }  .vertical-slider .value {    font-size: 12px;    color: #e5e5e5;    min-height: 16px;  }.clear-mode {  cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M14.9522 3C13.9146 3 13.0796 3.83502 11.4096 5.50506L6.5 10.4146L13.5854 17.5L18.4949 12.5904C20.165 10.9204 21 10.0854 21 9.04776C21 8.01013 20.165 7.1751 18.4949 5.50506C16.8249 3.83502 15.9899 3 14.9522 3Z'/%3E%3Cpath d='M13.5854 17.5001L6.5 10.4147L5.50506 11.4096C3.83502 13.0796 3 13.9147 3 14.9523C3 15.9899 3.83502 16.825 5.50506 18.495C7.1751 20.165 8.01013 21.0001 9.04776 21.0001C10.0854 21.0001 10.9204 20.165 12.5904 18.495L13.5854 17.5001Z'/%3E%3Cpath d='M9.06287 21C9.85928 20.9938 10.5389 20.4938 11.5734 19.5L21 19.5'/%3E%3C/svg%3E") 12 12, crosshair !important;}/* Interpolation */.interpolation-toolbar {    display: flex;    align-items: flex-start;    gap: 24px;    padding: 12px;    background: rgba(45, 45, 45, 0.8);    backdrop-filter: blur(20px);    border: 1px solid #454545;    border-radius: 8px;    }  .interpolation-group {    display: flex;    flex-direction: column;    gap: 4px;  }  .interpolation-group-title {    font-size: 10px;    color: #9ca3af;    text-transform: uppercase;    letter-spacing: 0.05em;    margin-bottom: 2px;    padding-left: 4px;  }  .interpolation-buttons {    display: flex;    gap: 8px;  }  .interpolation-btn {    width: 32px;    height: 32px;    background: #4a5568;    color: white;    border: 1px solid #6b7280;    border-radius: 6px;    cursor: pointer;    display: flex;    align-items: center;    justify-content: center;    transition: all 0.2s;    padding: 6px;  }  .interpolation-btn:hover {    background: #718096;    transform: translateY(-1px);  }  .interpolation-btn:active {    background: #374151;    transform: translateY(1px);  }  .interpolation-btn svg {    width: 100%;    height: 100%;  }  .interpolation-toolbar.hidden {    display: none;  }  .interpolation-btn:disabled {    opacity: 0.5;    cursor: not-allowed;  }/* Styles de base pour la modaleCoffee*/#coffeeBtn {  position: relative;  z-index: 1;  cursor: pointer;  transition: transform 0.2s;  background-color: #ffa500;}#coffeeBtn:hover {  transform: translateY(-3px);  background: #dd9400;}}#coffeeBtn:active {  transform: translateY(1px);}#aboutBtn {  position: relative;  z-index: 1;  cursor: pointer;  transition: transform 0.2s;  background-color: #4338CA;}#aboutBtn:hover {  transform: translateY(-3px);  background: #2327b9;}#aboutBtn:active {  transform: translateY(1px);}/* Animation du battement */@keyframes heartbeatBox {  0%, 100% {    transform: scale(1);  }  50% {    transform: scale(1.02);  }}/* Styles de la modale */#coffeeModal {  position: fixed;  inset: 0;  z-index: 2000; /* Plus élevé que les autres modales */  display: none;  align-items: center;  justify-content: center;  background-color: rgba(0, 0, 0, 0.5);  backdrop-filter: blur(4px);  opacity: 0;  transition: opacity 0.3s ease;  pointer-events: none;}#coffeeModal.active {  opacity: 1;  display: flex;  pointer-events: auto;}#coffeeModal .modal-content-welcome {  background: linear-gradient(135deg, #bb7100 0%, #ff9000 100%);  pointer-events: auto;  position: relative;   animation: gradientBG 10s ease infinite, heartbeatBox 2s ease-in-out infinite;  padding: 2rem;  border-radius: 1rem;  width: 100%;  max-width: 32rem;  transform: scale(0.95);  opacity: 0;  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);}#coffeeModal.active .modal-content-welcome {  transform: scale(1);  opacity: 1;}#coffeeModal.closing {  opacity: 0;  pointer-events: none;}#coffeeModal.closing .modal-content-welcome {  transform: scale(0.95);  opacity: 0;}/* Styles de la tasse de café */.coffee-cup {  position: relative;  filter: drop-shadow(0 0 10px rgba(255,255,255,0.3));}/* Styles du champ de montant */#coffeeAmount {  background: rgba(255,255,255,0.1);  backdrop-filter: blur(5px);  border: 1px solid rgba(255,255,255,0.2);  transition: all 0.3s ease;  color: white;  font-size: 1.5rem;  width: 80px;  text-align: center;  border-radius: 0.5rem;}#coffeeAmount:focus {  background: rgba(255,255,255,0.2);  border-color: rgba(255,255,255,0.4);  outline: none;  box-shadow: 0 0 0 2px rgba(255,255,255,0.1);}/* Styles du bouton PayPal */#paypalBtn {  background: #0070ba;  color: white;  border: none;  padding: 0.75rem 1.5rem;  border-radius: 0.5rem;  font-weight: 600;  transition: all 0.3s ease;  cursor: pointer;}#paypalBtn:hover {  background: #005ea6;  transform: translateY(-1px);  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);}#paypalBtn:active {  transform: translateY(1px);} .usage-info {    font-size: 0.95rem;    line-height: 1.5;    font-weight: 900;  }  .support-message {    font-size: 0.9rem;    line-height: 1.6;    font-weight: 600;  }  .usage-time {    color: #7f1d1d;    font-weight: 600;  }.gradient-text {    background: linear-gradient(90deg, #f59e0b, #dc2626);    -webkit-background-clip: text;    background-clip: text;    color: transparent;}  </style></head><body>  <div class="page-container">    <!-- Header -->    <header class="bg-indigo-900/90 backdrop-blur-sm shadow-lg border-b border-indigo-800 mb-4">      <div class="container mx-auto px-4 py-3 flex justify-between items-center">        <div class="flex items-center gap-3">          <svg class="w-8 h-8 text-indigo-300" viewBox="0 0 24 24" fill="none">            <path d="M9 17H6.5L2 12 6.5 7H9M15 17H17.5L22 12 17.5 7H15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>          </svg>          <div>            <h1 class="text-2xl font-semibold text-white flex items-center gap-2 gradient-text">              Fusion FX! Editor              <span class="text-xs font-normal px-2 py-1 bg-indigo-800 rounded-full text-indigo-200">v1.2</span>            </h1>            <p class="text-sm text-indigo-200">Smart AY Sound Effect Editor</p>          </div>        </div>        <div class="flex items-center gap-2">          <button id="aboutBtn" class="w-10 h-10 bg-indigo-700 hover:bg-indigo-600 rounded-md text-white flex items-center justify-center transition-all" title="Tell me more!">            <svg class="w-6 h-6" viewBox="0 0 1024 1024" fill="none">              <path d="M789.333333 853.333333H234.666667l-128 128V256c0-70.4 57.6-128 128-128h554.666666c70.4 0 128 57.6 128 128v469.333333c0 70.4-57.6 128-128 128z" fill="#FFFFFF"/>              <path d="M469.333333 426.666667h85.333334v234.666666h-85.333334z" fill="#2196F3"/>              <path d="M512 320m-42.666667 0a42.666667 42.666667 0 1 0 85.333334 0 42.666667 42.666667 0 1 0-85.333334 0Z" fill="#2196F3"/>            </svg>          </button>          <button id="coffeeBtn" class="w-10 h-10 bg-gradient-to-br from-amber-500 to-orange-500 rounded-md text-white flex items-center justify-center hover:from-amber-600 hover:to-orange-600 transition-all shadow-lg hover:shadow-xl hover:-translate-y-0.5 active:translate-y-0" title="Be kind 😊">            <svg class="w-6 h-6" viewBox="-5 0 32 32" fill="currentColor">              <path d="M12.406 14.75c-0.094-2.094-0.219-3.219-1.469-4.594-1.594-1.781-2.188-3.5-0.875-6.156 0.344 1.781 0.469 3.375 1.719 4.344s2.281 3.594 0.625 6.406zM10.063 14.75c-0.063-1.125-0.125-1.688-0.813-2.469-0.844-0.938-1.188-1.844-0.469-3.281 0.188 0.969 0.219 1.813 0.906 2.313s1.281 1.938 0.375 3.438zM15.719 24.625h5.688c0.344 0 0.469 0.25 0.25 0.531 0 0-2.219 2.844-5.281 2.844h-10.969s-5.281-2.844-5.281-2.844c-0.219-0.281-0.125-0.531 0.219-0.531h5.625c-0.781-0.406-1.938-2.188-1.938-4.406v-4.688h13.688v0.375c0.438-0.375 0.969-0.563 1.531-0.563 0.781 0 2.25 0.813 2.25 2.219 0 2.031-1.344 2.781-2.125 3.313 0 0-1.469 1.156-2.5 2.5-0.344 0.594-0.75 1.063-1.156 1.25zM19.25 16.188c-0.5 0-1.125 0.219-1.531 1.219v2.594c0 0.344-0.031 0.75-0.094 1.094 0.688-0.688 1.5-1.156 1.5-1.156 0.5-0.344 1.5-1 1.5-2.281 0.031-0.906-0.813-1.469-1.375-1.469zM6.406 16.563h-0.875v1.281h0.875v-1.281zM6.406 18.594h-0.875v2.094s0.25 2.813 2.031 3.656c-1.094-1.281-1.156-2.75-1.156-3.656v-2.094z"/>            </svg>          </button>        </div>      </div>    </header>    <!-- Main Content -->    <div class="main-content">      <!-- Left Panel -->      <div class="left-panel">        <!-- File Operations -->        <div class="panel-section">          <h3 class="text-white font-semibold mb-3">FX Bank Management</h3>          <div class="flex flex-col gap-2">           <button id="importBtn" class="btn" data-tooltip="Import .afb Bank File">  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>    <line x1="7" y1="15" x2="17" y2="15"/>    <line x1="7" y1="19" x2="11" y2="19"/>    <path d="M12 3v8"/>    <path d="m8 8 4 3 4-3"/>  </svg>  Import Bank</button><!-- Export Bank Button --><button id="downloadAfbBtn" class="btn" data-tooltip="Export .afb Bank File">  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>    <line x1="7" y1="7" x2="17" y2="7"/>    <line x1="7" y1="11" x2="17" y2="11"/>    <path d="M12 13v8"/>    <path d="m8 17 4 3 4-3"/>  </svg>  Export Bank</button>                      <input type="file" id="importWavFile" accept=".wav" class="hidden" />            <input type="file" id="loadAfxFile" accept=".afx" class="hidden" />            <input type="file" id="importFile" accept=".afb" class="hidden" />          </div>        </div>        <!-- FX Name -->        <div class="panel-section">          <div class="fx-name space-y-3">            <div>                <h3 class="text-white font-semibold mb-3">FX Name / Selection</h3>              <input type="text" id="fxName" value="FX" class="w-full bg-gray-700 border border-gray-600 rounded-md px-2 py-1" />            </div>            <div>              <div id="fxIndicator" class="text-sm text-gray-400 mb-1"></div>              <select id="fxSelect" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2"></select>            </div>          </div>        </div>        <!-- Piano (Collapsible) -->        <div class="panel-section piano-container">          <div class="piano-header" id="pianoToggle">            <h3 class="text-white font-semibold">Piano Controls</h3>            <span class="toggle-icon">▼</span>          </div>          <div class="piano-content">            <div class="flex gap-4 mb-3">              <label>Octave:                <select id="octaveSelect" class="bg-gray-700 border border-gray-600 rounded-md">                  <option>1</option><option>2</option><option>3</option>                  <option>4</option><option selected>5</option><option>6</option>                  <option>7</option><option>8</option>                </select>              </label>              <label>Volume:                <select id="pianoVolume" class="bg-gray-700 border border-gray-600 rounded-md">                  <option value="0">0</option>                  <option value="1">1</option>                  <option value="2">2</option>                  <option value="3">3</option>                  <option value="4">4</option>                  <option value="5">5</option>                  <option value="6">6</option>                  <option value="7">7</option>                  <option value="8">8</option>                  <option value="9">9</option>                  <option value="10" selected>10</option>                  <option value="11">11</option>                  <option value="12">12</option>                  <option value="13">13</option>                  <option value="14">14</option>                  <option value="15">15</option>                </select>              </label>            </div>            <div class="flex gap-4 mb-3">              <label><input type="checkbox" id="pianoSetT" checked> T</label>              <label><input type="checkbox" id="pianoSetN" checked> N</label>            </div>            <div class="piano-keys">              <button data-note="C">C</button>              <button data-note="C#" class="black">C#</button>              <button data-note="D">D</button>              <button data-note="D#" class="black">D#</button>              <button data-note="E">E</button>              <button data-note="F">F</button>              <button data-note="F#" class="black">F#</button>              <button data-note="G">G</button>              <button data-note="G#" class="black">G#</button>              <button data-note="A">A</button>              <button data-note="A#" class="black">A#</button>              <button data-note="B">B</button>            </div>          </div>          <div class="flex gap-4 mb-3">  <div class="flex items-center gap-2">    <label title="Number of frames to skip to next note">Step:</label>    <div class="flex items-center">      <button class="btn-stepper-minus bg-gray-700 px-2 text-sm border border-gray-600 rounded-l-md">-</button>      <input type="number" id="pianoStep" value="1" min="1" max="32"              class="w-7 bg-gray-700 border-y border-gray-600 text-center py-1 no-spin" />      <button class="btn-stepper-plus bg-gray-700 px-2 text-sm border border-gray-600 rounded-r-md">+</button>    </div>  </div>    <div class="flex items-center gap-2">    <label title="Number of frames to fill with the same note">Fill:</label>    <div class="flex items-center">      <button class="btn-stepper-minus bg-gray-700 px-2 text-sm border border-gray-600 rounded-l-md">-</button>      <input type="number" id="pianoFill" value="1" min="1" max="32"              class="w-7 bg-gray-700 border-y border-gray-600 text-center py-1 no-spin" />      <button class="btn-stepper-plus bg-gray-700 px-2 text-sm border border-gray-600 rounded-r-md">+</button>    </div>  </div></div>        </div><!-- Wav Import controls--><!-- Modification du panneau WAV Controls --><div class="panel-section piano-container collapsed">  <div class="piano-header" id="wavControlsToggle">    <h3 class="text-white font-semibold">WAV Controls</h3>    <span class="toggle-icon">▶</span>  </div>  <div class="piano-content">    <!-- Paramètres d'import -->    <div class="text-sm text-gray-400 mb-2 font-semibold">Import Parameters</div>    <div class="horizontal-sliders-container space-y-6">      <!-- Volume Scale Slider -->      <div class="horizontal-slider mb-4">        <div class="flex justify-between mb-1">          <label>Volume Scale</label>          <span class="value" id="volumeScaleValue">2.6</span>        </div>        <input type="range"               id="volumeScaleSlider"               min="1"               max="5"               step="0.1"               value="2.6"               class="w-full bg-gray-700 rounded-md h-2 appearance-none">      </div>            <!-- Pitch Threshold Slider -->      <div class="horizontal-slider mb-4">        <div class="flex justify-between mb-1">          <label>Pitch Threshold</label>          <span class="value" id="pitchThresholdValue">0.1</span>        </div>        <input type="range"               id="pitchThresholdSlider"               min="0.05"               max="0.3"               step="0.01"               value="0.1"               class="w-full bg-gray-700 rounded-md h-2 appearance-none">      </div>            <!-- Noise Sensitivity Slider -->      <div class="horizontal-slider mb-4">        <div class="flex justify-between mb-1">          <label>Noise Sensitivity</label>          <span class="value" id="noiseSensitivityValue">10</span>        </div>        <input type="range"               id="noiseSensitivitySlider"               min="1"               max="100"               step="1"               value="10"               class="w-full bg-gray-700 rounded-md h-2 appearance-none">      </div>    </div>        <!-- Paramètres d'export -->    <div class="text-sm text-gray-400 mt-4 mb-2 font-semibold">Export Parameters</div>    <div class="grid grid-cols-2 gap-4">      <!-- Sélecteur du taux d'échantillonnage -->      <div>        <label class="block text-sm text-gray-400 mb-1">Sample Rate</label>        <select id="sampleRateSelect" class="w-full bg-gray-700 border border-gray-600 rounded-md px-2 py-1">          <option value="44100" selected>44.1 kHz</option>          <option value="22050">22.05 kHz</option>          <option value="11025">11 kHz</option>          <option value="8000">8 kHz</option>        </select>      </div>      <!-- Sélecteur du format d'export -->      <div>        <label class="block text-sm text-gray-400 mb-1">Export Format</label>      <select id="exportFormatSelect" class="w-full bg-gray-700 border border-gray-600 rounded-md px-2 py-1" onchange="updateExportButtonTooltip()">  <option value="wav" selected>WAV Standard</option>  <option value="pcm">PCM 8-bit (no header)</option>  <option value="adpcm">ADPCM 4-bit (no header)</option></select>      </div>    </div>  </div></div>        <!-- Import FX -->        <div class="panel-section">          <h3 class="text-white font-semibold mb-2">Import FX</h3>          <div class="import-fx-data">            <textarea id="fxImportData" class="w-full mb-2 bg-gray-700 border border-gray-600 rounded-md px-2 py-1 min-h-[80px] resize-y" placeholder="Paste FX data here"></textarea>            <div align=center>             <button id="pasteFxBtn" class="btn" data-tooltip="Insert FX Data in current FX">                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">                  <path d="M8 3v3a2 2 0 0 1-2 2H3"/>                  <path d="M16 3v3a2 2 0 0 0 2 2h3"/>                  <path d="M21 16v3a2 2 0 0 1-2 2h-3"/>                  <path d="M3 16v3a2 2 0 0 0 2 2h3"/>                  <line x1="12" y1="7" x2="12" y2="17"/>                  <line x1="7" y1="12" x2="17" y2="12"/>                </svg>                Insert into current FX              </button>            </div>          </div>        </div>      </div>      <!-- Editor Section -->      <div class="editor-section">        <div class="canvas-container">          <canvas id="editorCanvas" width="765" height="250"></canvas>          <div id="playIndicator" class="mt-3">            <div id="progressBar"></div>          </div>        </div>        <!-- Editor Controls -->   <div class="panel-section bg-gray-900 p-4">  <div class="flex items-start gap-4">    <!-- Controls section -->    <div class="flex flex-col items-center">      <span class="text-xs text-gray-500 mb-2">Controls</span>      <div class="flex gap-2">        <button id="playBtn" class="btn btn-primary btn-icon" data-tooltip="Play Effect">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <polygon points="5 3 19 12 5 21 5 3"/>          </svg>        </button>        <button id="stopBtn" class="btn btn-danger btn-icon" data-tooltip="Stop Playback">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>          </svg>        </button>        <button id="prevFxBtn" class="btn btn-icon" data-tooltip="Previous FX">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <polyline points="15 18 9 12 15 6"/>          </svg>        </button>        <button id="nextFxBtn" class="btn btn-icon" data-tooltip="Next FX">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <polyline points="9 18 15 12 9 6"/>          </svg>        </button>      </div>    </div>    <div class="h-full border-l border-gray-700"></div>    <!-- Edition section -->    <div class="flex flex-col items-center">      <span class="text-xs text-gray-500 mb-2">Edition</span>      <div class="flex gap-2">               <button id="toggleSelectionModeBtn" class="btn btn-icon" data-tooltip="Toggle Edit/Selection Mode">          <svg class="mode-icon edit-mode" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>          </svg>          <svg class="mode-icon selection-mode hidden" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>          </svg>        </button>        <button id="copySelectionBtn" class="btn btn-icon" data-tooltip="Copy Selection" disabled>          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>          </svg>        </button>        <button id="pasteSelectionBtn" class="btn btn-icon" data-tooltip="Paste Selection" disabled>          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>            <path d="M15 2H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1z"/>          </svg>        </button>      </div>    </div>    <div class="h-full border-l border-gray-700"></div>    <!-- Import/Export section -->    <div class="flex flex-col items-center">      <span class="text-xs text-gray-500 mb-2">Import / Export</span>      <div class="flex gap-2">        <button id="copyBtn" class="btn btn-icon" data-tooltip="Copy current FX data to ClipBoard">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>            <path d="M15 2H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1z"/>            <line x1="8" y1="10" x2="16" y2="10"/>            <line x1="8" y1="14" x2="16" y2="14"/>            <line x1="8" y1="18" x2="12" y2="18"/>          </svg>        </button>        <button id="loadAfxBtn" class="btn btn-icon" data-tooltip="Load .afx file to current FX">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/>            <path d="M12 12v9"/>            <path d="m16 17-4-4-4 4"/>          </svg>        </button>        <button id="saveAfxBtn" class="btn btn-icon" data-tooltip="Save current FX as .afx file">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/>            <path d="M12 12v9"/>            <path d="m8 17 4 4 4-4"/>          </svg>        </button>        <button id="downloadWavBtn" class="btn btn-icon" data-tooltip="Save current FX as WAV file">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <path d="M4 2h12l4 4v14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z"/>            <line x1="12" y1="5" x2="12" y2="9"/>            <polyline points="10,7 12,9 14,7"/>            <polyline points="6,16 8,14 10,16 12,14 14,16 16,14"/>          </svg>        </button>        <button id="importWavBtn" class="btn btn-icon" data-tooltip="Import & Convert WAV file to current FX">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <g transform="translate(0,24) scale(1,-1)">              <path d="M4 2h12l4 4v14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z"/>              <line x1="12" y1="5" x2="12" y2="9"/>              <polyline points="10,7 12,9 14,7"/>              <polyline points="6,16 8,14 10,16 12,14 14,16 16,14"/>            </g>          </svg>        </button>      </div>    </div>    <div class="h-full border-l border-gray-700"></div>    <!-- Bank section -->    <div class="flex flex-col items-center">      <span class="text-xs text-gray-500 mb-2">Bank</span>      <div class="flex gap-2">        <button id="newFxBtn" class="btn btn-icon" data-tooltip="Add new FX in bank">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <line x1="12" y1="5" x2="12" y2="19"/>            <line x1="5" y1="12" x2="19" y2="12"/>          </svg>        </button>        <button id="deleteFxBtn" class="btn btn-danger btn-icon" data-tooltip="Delete current FX">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <path d="M3 6h18"/>            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>          </svg>        </button>      </div>    </div>    <div class="h-full border-l border-gray-700"></div>    <!-- Interface section -->    <div class="flex flex-col items-center">      <span class="text-xs text-gray-500 mb-2">Interface</span>      <div class="flex gap-2">    <button id="clearModeBtn" class="btn btn-icon" data-tooltip="Toggle Clear Mode">  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">    <path d="M14.9522 3C13.9146 3 13.0796 3.83502 11.4096 5.50506L6.5 10.4146L13.5854 17.5L18.4949 12.5904C20.165 10.9204 21 10.0854 21 9.04776C21 8.01013 20.165 7.1751 18.4949 5.50506C16.8249 3.83502 15.9899 3 14.9522 3Z"/>    <path d="M13.5854 17.5001L6.5 10.4147L5.50506 11.4096C3.83502 13.0796 3 13.9147 3 14.9523C3 15.9899 3.83502 16.825 5.50506 18.495C7.1751 20.165 8.01013 21.0001 9.04776 21.0001C10.0854 21.0001 10.9204 20.165 12.5904 18.495L13.5854 17.5001Z"/>    <path d="M9.06287 21C9.85928 20.9938 10.5389 20.4938 11.5734 19.5L21 19.5"/>  </svg></button>        <button id="liveModeBtn" class="btn btn-icon" data-tooltip="Toggle Sound Live Mode">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>            <path d="M15 9c1 1 1.5 2.5 1.5 4s-.5 3-1.5 4"/>            <path d="M18 7c1.5 1.5 2.5 3.5 2.5 6s-1 4.5-2.5 6"/>          </svg>        </button>              <button id="toggleHzBtn" class="btn btn-icon" data-tooltip="Toggle to 60Hz">          <svg id="icon50Hz" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <text x="10" y="12" text-anchor="middle" font-size="14" font-family="monospace" fill="currentColor" stroke="none">50</text>            <text x="16" y="24" text-anchor="middle" font-size="12" font-family="monospace" fill="currentColor" stroke="none"> Hz</text>          </svg>          <svg id="icon60Hz" class="hidden" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <text x="10" y="12" text-anchor="middle" font-size="14" font-family="monospace" fill="currentColor" stroke="none">60</text>            <text x="16" y="24" text-anchor="middle" font-size="12" font-family="monospace" fill="currentColor" stroke="none"> Hz</text>          </svg>        </button>          <button id="zoomBtn" class="btn btn-icon" data-tooltip="Zoom In Editor area (5px/frame)">          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>            <line x1="8" y1="21" x2="16" y2="21"/>            <line x1="12" y1="17" x2="12" y2="21"/>            <line x1="8" y1="10" x2="16" y2="10"/>            <line x1="12" y1="6" x2="12" y2="14"/>          </svg>        </button>      </div>    </div>  </div></div><!-- Interpolation --><div id="interpolationToolbar" class="interpolation-toolbar hidden">  <div class="interpolation-group">    <div class="interpolation-group-title">Apply interpolation to Volume</div>    <div class="interpolation-buttons">      <button class="interpolation-btn" title="Linear Volume Up">        <svg width="20" height="20" viewBox="0 0 24 32" fill="none" stroke="currentColor" stroke-width="2">          <path d="M3 20L21 4" stroke-linecap="round"/>          <text x="12" y="30" text-anchor="middle" font-size="10" fill="currentColor">VOL</text>        </svg>      </button>      <button class="interpolation-btn" title="Linear Volume Down">        <svg width="20" height="20" viewBox="0 0 24 32" fill="none" stroke="currentColor" stroke-width="2">          <path d="M3 4L21 20" stroke-linecap="round"/>          <text x="12" y="30" text-anchor="middle" font-size="10" fill="currentColor">VOL</text>        </svg>      </button>      <button class="interpolation-btn" title="Parabolic Volume">        <svg width="20" height="20" viewBox="0 0 24 32" fill="none" stroke="currentColor" stroke-width="2">          <path d="M3 20C3 20 8 4 12 4C16 4 21 20 21 20" stroke-linecap="round"/>          <text x="12" y="30" text-anchor="middle" font-size="10" fill="currentColor">VOL</text>        </svg>      </button>      <button class="interpolation-btn" title="Inverse Parabolic Volume">        <svg width="20" height="20" viewBox="0 0 24 32" fill="none" stroke="currentColor" stroke-width="2">          <path d="M3 4C3 4 8 20 12 20C16 20 21 4 21 4" stroke-linecap="round"/>          <text x="12" y="30" text-anchor="middle" font-size="10" fill="currentColor">VOL</text>        </svg>      </button>      <button class="interpolation-btn" title="Flat Normalize Volume">        <svg width="20" height="20" viewBox="0 0 24 32" fill="none" stroke="currentColor" stroke-width="2">          <path d="M3 12L21 12" stroke-linecap="round"/>          <text x="12" y="30" text-anchor="middle" font-size="10" fill="currentColor">VOL</text>        </svg>      </button>    </div>  </div>  <div class="interpolation-group">    <div class="interpolation-group-title">Apply interpolation to Tone</div>    <div class="interpolation-buttons">      <button class="interpolation-btn" title="Linear Tone Up">        <svg width="20" height="20" viewBox="0 0 24 32" fill="none" stroke="currentColor" stroke-width="2">          <path d="M3 20L21 4" stroke-linecap="round"/>          <path d="M3 16L21 0" stroke-linecap="round" stroke-opacity="0.5"/>          <text x="12" y="30" text-anchor="middle" font-size="10" fill="currentColor">TONE</text>        </svg>      </button>      <button class="interpolation-btn" title="Linear Tone Down">        <svg width="20" height="20" viewBox="0 0 24 32" fill="none" stroke="currentColor" stroke-width="2">          <path d="M3 4L21 20" stroke-linecap="round"/>          <path d="M3 0L21 16" stroke-linecap="round" stroke-opacity="0.5"/>          <text x="12" y="30" text-anchor="middle" font-size="10" fill="currentColor">TONE</text>        </svg>      </button>      <button class="interpolation-btn" title="Parabolic Tone">        <svg width="20" height="20" viewBox="0 0 24 32" fill="none" stroke="currentColor" stroke-width="2">          <path d="M3 20C3 20 8 4 12 4C16 4 21 20 21 20" stroke-linecap="round"/>          <path d="M3 16C3 16 8 0 12 0C16 0 21 16 21 16" stroke-linecap="round" stroke-opacity="0.5"/>          <text x="12" y="30" text-anchor="middle" font-size="10" fill="currentColor">TONE</text>        </svg>      </button>      <button class="interpolation-btn" title="Inverse Parabolic Tone">        <svg width="20" height="20" viewBox="0 0 24 32" fill="none" stroke="currentColor" stroke-width="2">          <path d="M3 4C3 4 8 20 12 20C16 20 21 4 21 4" stroke-linecap="round"/>          <path d="M3 0C3 0 8 16 12 16C16 16 21 0 21 0" stroke-linecap="round" stroke-opacity="0.5"/>          <text x="12" y="30" text-anchor="middle" font-size="10" fill="currentColor">TONE</text>        </svg>      </button>      <button class="interpolation-btn" title="Flat Normalize Tone">        <svg width="20" height="20" viewBox="0 0 24 32" fill="none" stroke="currentColor" stroke-width="2">          <path d="M3 12L21 12" stroke-linecap="round"/>          <path d="M3 8L21 8" stroke-linecap="round" stroke-opacity="0.5"/>          <text x="12" y="30" text-anchor="middle" font-size="10" fill="currentColor">TONE</text>        </svg>      </button>    </div>  </div></div>        <!-- Legend -->       <div class="panel-section piano-container">          <div class="piano-header" id="legendToggle">            <h3 class="text-white font-semibold">Legend</h3>            <span class="toggle-icon">▼</span>          </div>          <div class="piano-content">            <div class="grid grid-cols-2 gap-2 text-gray-200">              <p><span style="background:#c66; border-color: #a44"></span> T line : Tone toggle ON/OFF</p>              <p><span style="background:#6c6; border-color: #4a4"></span> N line : Noise toggle ON/OFF</p>              <p><span style="background:#66c; border-color: #44a"></span> Tone line : tone level (0..4095)</p>              <p><span style="background:#cc6; border-color: #aa4"></span> Noise line : noise level (0..31)</p>              <p><span style="background:#6cc; border-color: #4aa"></span> Volume line : volume level(0..15)</p>            </div>            <style>              .grid span {                box-shadow: 0 0 4px rgba(0,0,0,0.2);                border-width: 2px;              }            </style>            <p class="mt-2 text-sm text-gray-400">255 frames (X from 0 to 254). Use left click to draw or modify. Right Click to erase.<br>              Use cursor (white line) to a position on the editor. Cursor position is the start point for piano note, or paste data.</p>          </div>        </div>    <!-- Footer -->    <footer class="mt-8 py-4 px-6 text-center">      <p class="text-xs text-gray-400">        Fusion FX! Editor © 2025 EBsoft Studio<br>        <span class="text-gray-500">for Fusion-C SDK 2.0 (2018-2025) - Creative Commons CC BY-SA 4.0</span>      </p>    </footer>  </div>  <!-- About Modal --><div id="aboutModal" class="modal hidden">  <div class="modal-content p-6 relative">    <button class="close-modal absolute top-2 right-2 text-2xl text-gray-400 hover:text-white">&times;</button>        <!-- Header and Title -->    <div class="mb-6">      <h2 class="text-xl font-bold text-white mb-2">About Fusion FX! Editor</h2>      <p class="text-gray-300">        Fusion FX! Editor is a sophisticated tool for creating and editing sound effects for the AY-3-8910 & YM2149 (PSG) sound chips,         (commonly used in MSX computers, Amstrad CPC, ZX Spectrum +2/+3, Ataris ST, Dragon 32/64 and other vintage systems). This tool is compatible with Shiru's AYFX sound bank format (.afb), and individual FX (.afx) files format.      </p>    </div>    <!-- Content in two columns -->    <div class="flex flex-col md:flex-row">      <!-- First column -->      <div class="md:w-1/2 md:pr-4 md:border-r md:border-gray-600">        <div class="mb-6">          <h3 class="text-lg font-semibold text-white mb-2">Editor Features</h3>          <ul class="list-disc pl-5 space-y-2 text-gray-300">            <li>              Visual waveform editing controls:              <ul class="list-none mt-1 ml-4 text-gray-400 space-y-1">                <li>• T (Toggle): Enable/disable tone generation</li>                <li>• N (Noise): Enable/disable noise generation</li>                <li>• Tone (0-4095): Control tone frequency</li>                <li>• Noise (0-31): Control noise frequency</li>                <li>• Volume (0-15): Control sound volume</li>              </ul>            </li>            <li>              Mouse-based editing:              <ul class="list-none mt-1 ml-4 text-gray-400 space-y-1">                <li>• Left click & drag to draw/modify values</li>                <li>• Right click to erase/reset values</li>                <li>• Precise value control with vertical position</li>                <li>• Draggable cursor for frame selection</li>                <li>• Instant visual feedback</li>              </ul>            </li>            <li>              Advanced editing tools:              <ul class="list-none mt-1 ml-4 text-gray-400 space-y-1">                <li>• Selection mode with bulk editing</li>                <li>• Copy/paste frame ranges</li>                <li>• Linear and parabolic interpolation</li>                <li>• Live preview mode with instant feedback</li>                <li>• Variable frame width (4px/5px per frame)</li>              </ul>            </li>          </ul>        </div>      </div>      <!-- Second column -->      <div class="md:w-1/2 md:pl-4">        <div class="mb-6">          <h3 class="text-lg font-semibold text-white mb-2">Advanced Features</h3>          <ul class="list-disc pl-5 space-y-2 text-gray-300">             <li>              Real-time visualization:              <ul class="list-none mt-1 ml-4 text-gray-400 space-y-1">                <li>• Live tone waveform display</li>                <li>• Dynamic noise pattern visualization</li>                <li>• Real-time parameter updates</li>                <li>• Interactive cursor control</li>                <li>• Frequency display in Hz</li>              </ul>            </li>            <li>              Virtual Piano Interface:              <ul class="list-none mt-1 ml-4 text-gray-400 space-y-1">                <li>• 8 octave range selection</li>                <li>• Adjustable volume per note</li>                <li>• T/N toggle support</li>                <li>• Real-time sound preview</li>              </ul>            </li>            <li>              File Format Support:              <ul class="list-none mt-1 ml-4 text-gray-400 space-y-1">                <li>• AFB format for sound banks</li>                <li>• AFX format for individual effects</li>                <li>• WAV import with conversion</li>                <li>• WAV export for testing</li>              </ul>            </li>            <li>              WAV Import Features:              <ul class="list-none mt-1 ml-4 text-gray-400 space-y-1">                <li>• Adjustable volume scaling</li>                <li>• Pitch detection threshold</li>                <li>• Noise sensitivity control</li>                <li>• Automatic conversion to AY format</li>              </ul>            </li>            <li>              Playback Controls:              <ul class="list-none mt-1 ml-4 text-gray-400 space-y-1">                <li>• 50/60 Hz playback toggle</li>                <li>• Live preview mode</li>                <li>• Progress bar visualization</li>                <li>• Frame-by-frame navigation</li>              </ul>            </li>          </ul>        </div>      </div>    </div>    <!-- Footer -->    <div class="mb-6" align="center">       <a href="http://ebsoft.studio/fusion/AY-FX_assets.zip">Download a collection of bank files (.afb) and SFX files (.afx) by clicking here</a><br>      <p class="text-sm text-gray-400 mt-5">        This tool was created for Fusion-C SDK 2.0 (2018-2025)<br>        Creative Commons CC BY-SA 4.0<br>        Design and development by Eric Boez with the help of Claude AI<br>        © 2025 EBsoft Studio      </p>    </div>  </div></div><div id="coffeeModal" class="modal hidden">  <div class="modal-content-welcome relative">    <!-- Bouton de fermeture -->    <button class="close-modal absolute top-4 right-4 text-gray-400 hover:text-white">      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">        <path d="M18 6L6 18M6 6l12 12" stroke-width="2" stroke-linecap="round"/>      </svg>    </button>    <!-- En-tête avec icône et titre -->    <div class="flex items-center gap-6 mb-8">      <!-- Icône de tasse de café animée -->      <div class="coffee-cup">        <svg class="w-24 h-24" viewBox="-5 0 32 32" fill="white">          <path d="M12.406 14.75c-0.094-2.094-0.219-3.219-1.469-4.594-1.594-1.781-2.188-3.5-0.875-6.156 0.344 1.781 0.469 3.375 1.719 4.344s2.281 3.594 0.625 6.406zM10.063 14.75c-0.063-1.125-0.125-1.688-0.813-2.469-0.844-0.938-1.188-1.844-0.469-3.281 0.188 0.969 0.219 1.813 0.906 2.313s1.281 1.938 0.375 3.438zM15.719 24.625h5.688c0.344 0 0.469 0.25 0.25 0.531 0 0-2.219 2.844-5.281 2.844h-10.969s-5.281-2.844-5.281-2.844c-0.219-0.281-0.125-0.531 0.219-0.531h5.625c-0.781-0.406-1.938-2.188-1.938-4.406v-4.688h13.688v0.375c0.438-0.375 0.969-0.563 1.531-0.563 0.781 0 2.25 0.813 2.25 2.219 0 2.031-1.344 2.781-2.125 3.313 0 0-1.469 1.156-2.5 2.5-0.344 0.594-0.75 1.063-1.156 1.25zM19.25 16.188c-0.5 0-1.125 0.219-1.531 1.219v2.594c0 0.344-0.031 0.75-0.094 1.094 0.688-0.688 1.5-1.156 1.5-1.156 0.5-0.344 1.5-1 1.5-2.281 0.031-0.906-0.813-1.469-1.375-1.469zM6.406 16.563h-0.875v1.281h0.875v-1.281zM6.406 18.594h-0.875v2.094s0.25 2.813 2.031 3.656c-1.094-1.281-1.156-2.75-1.156-3.656v-2.094z"/>        </svg>      </div>      <div>        <h2 class="text-2xl font-semibold text-white mb-2">Support My Work!</h2>        <p class="text-indigo-200">Help me keep developing awesome tools</p>      </div>    </div>    <!-- Message de temps d'utilisation et support -->    <div class="support-message mb-6 text-center text-indigo-200 px-4">      <p class="mb-3">You've been using Fusion FX! Editor for <br> <span class="font-bold text-red-840 usage-time">calculating...</span></p>      <p class="mb-2">This tool is the result of countless hours of development, testing, and refinement. It's free and open-source, but your support helps me continue improving it and creating more tools for the retro computer community.</p>      <p>Even a small contribution - the price of a coffee - makes a big difference and shows your appreciation for the work!</p>    </div>    <!-- Sélection du montant -->    <div class="text-center mb-8">      <div class="amount-input flex items-center justify-center gap-2 mb-4">        <span class="text-2xl text-white">€</span>        <input type="number"                id="coffeeAmount"                value="3"                min="1"                max="100"               class="w-20 text-2xl bg-white/10 border border-white/20 rounded px-3 py-2 text-white text-center">      </div>      <div class="grid grid-cols-3 gap-2 max-w-xs mx-auto mb-4">        <button class="px-4 py-2 rounded bg-white/10 hover:bg-white/20 text-white transition-colors" onclick="document.getElementById('coffeeAmount').value='3'">€3</button>        <button class="px-4 py-2 rounded bg-white/10 hover:bg-white/20 text-white transition-colors" onclick="document.getElementById('coffeeAmount').value='5'">€5</button>        <button class="px-4 py-2 rounded bg-white/10 hover:bg-white/20 text-white transition-colors" onclick="document.getElementById('coffeeAmount').value='10'">€10</button>      </div>    </div>    <!-- Bouton PayPal -->    <div class="flex justify-center">      <button id="paypalBtn" class="modal-btn primary px-6 py-3 flex items-center gap-2">        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">          <path d="M6 17h12a2 2 0 002-2V9a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2z"/>          <path d="M6 13h12"/>        </svg>        Support with PayPal      </button>    </div>  </div></div><script>    // Modal handling    const aboutBtn = document.getElementById('aboutBtn');    const aboutModal = document.getElementById('aboutModal');    const closeModalBtn = document.querySelector('.close-modal');    aboutBtn.addEventListener('click', () => {      aboutModal.classList.remove('hidden');    });    closeModalBtn.addEventListener('click', () => {      aboutModal.classList.add('hidden');    });    window.addEventListener('click', (event) => {      if (event.target === aboutModal) {        aboutModal.classList.add('hidden');      }    });    // Piano toggle functionality    const pianoToggle = document.getElementById('pianoToggle');    const pianoContainer = document.querySelector('.piano-container');    const toggleIcon = document.querySelector('.toggle-icon');    let isPianoCollapsed = true;    // Fonction pour appliquer l'état collapsed    function applyPianoCollapsed() {      if (isPianoCollapsed) {        pianoContainer.style.height = pianoToggle.offsetHeight + 'px';        toggleIcon.textContent = '▶';      } else {        pianoContainer.style.height = 'auto';        toggleIcon.textContent = '▼';      }    }   // Appliquer l'état initial au chargement    document.addEventListener('DOMContentLoaded', () => {      applyPianoCollapsed();      updateExportButtonTooltip();    });    // Gestionnaire de clic existant    pianoToggle.addEventListener('click', () => {      isPianoCollapsed = !isPianoCollapsed;      applyPianoCollapsed();    });// Modification du gestionnaire d'événements des touches du pianodocument.addEventListener('DOMContentLoaded', () => {  // Ajouter les gestionnaires d'événements pour les boutons stepper  document.querySelectorAll('.btn-stepper-minus, .btn-stepper-plus').forEach(button => {    button.addEventListener('click', (e) => {      const isPlus = e.target.classList.contains('btn-stepper-plus');      const input = e.target.parentNode.querySelector('input');      let value = parseInt(input.value, 10) || 1;            if (isPlus) {        value = Math.min(99, value + 1);      } else {        value = Math.max(1, value - 1);      }            input.value = value;    });  });    // S'assurer que les inputs n'acceptent que des nombres valides et limités à 2 caractères  document.querySelectorAll('#pianoStep, #pianoFill').forEach(input => {    // Limiter la saisie à 2 caractères numériques    input.setAttribute('maxlength', '2');        // Empêcher la saisie de caractères non numériques    input.addEventListener('keypress', (e) => {      if (!/[0-9]/.test(e.key)) {        e.preventDefault();      }    });        // Valider la valeur après changement    input.addEventListener('change', () => {      let value = parseInt(input.value, 10);            // Gérer les valeurs invalides ou hors limites      if (isNaN(value) || value < 1) {        value = 1;      } else if (value > 99) {        value = 99;      }            input.value = value;    });        // Validation supplémentaire lors de la perte de focus    input.addEventListener('blur', () => {      if (input.value === '' || input.value === '0') {        input.value = '1';      }    });  });  // Modifier le comportement des touches du piano  const pianoKeys = document.querySelectorAll('.piano-keys button');    pianoKeys.forEach(btn => {    // Supprimer tous les gestionnaires d'événements existants    const clone = btn.cloneNode(true);    btn.parentNode.replaceChild(clone, btn);        // Ajouter le nouveau gestionnaire d'événements    clone.addEventListener('click', (e) => {      const note = e.target.dataset.note;      const octave = parseInt(octaveSelect.value, 10);      const tone = noteToTone(note, octave);      const frames = getCurrentFrames();            // Récupérer les valeurs de Step et Fill      const stepValue = parseInt(document.getElementById('pianoStep').value, 10) || 1;      const fillValue = parseInt(document.getElementById('pianoFill').value, 10) || 1;            // Vérifier si on peut placer la note (éviter de dépasser la limite)      if (cursorIndex + fillValue > NUM_FRAMES) {        notifyInfo(`Cannot place note: would exceed frame limit (${NUM_FRAMES})`);        return;      }            // Appliquer les valeurs sur plusieurs frames selon Fill      for (let i = 0; i < fillValue; i++) {        const frameIndex = cursorIndex + i;        frames[frameIndex].tone = tone;        frames[frameIndex].t = pianoSetT.checked;        frames[frameIndex].n = pianoSetN.checked;        frames[frameIndex].volume = parseInt(pianoVolume.value, 10);      }            // Jouer la note (fonctionnalité originale préservée)      playPianoKey(note, octave);            // Avancer le curseur selon Step et Fill (le maximum des deux)      const advance = Math.max(stepValue, fillValue);      moveCursor(cursorIndex + advance);            renderAll();    });  });});  </script> <script>    /******************************************************************     * Paramètres     ******************************************************************/    let NUM_FRAMES = 255;    let NUM_ROWS = 5;    let ROW_HEIGHT = 50;    let COL_WIDTH = 4;    let FRAME_WIDTH = 4;    let CANVAS_WIDTH = 1024; // 4px per frame    let RANGE_TONE = 4095;    let RANGE_NOISE = 31;    let RANGE_VOLUME = 15;    let lastFxName = "FX1";    let SCALE_HEIGHT = 30;    const LABEL_WIDTH = 40;    const ROW_SPACING = 8;// Row configuration with heights and colorsconst ROWS = [  { name: 'T', height: 30, color: '#c66', maxValue: 1, type: 'toggle', field: 't' },  { name: 'N', height: 30, color: '#6c6', maxValue: 1, type: 'toggle', field: 'n' },  { name: 'TONE', height: 200, color: '#66c', maxValue: 4095, type: 'value', field: 'tone' },  { name: 'NOISE', height: 80, color: '#cc6', maxValue: 31, type: 'value', field: 'noise' },  { name: 'VOL', height: 80, color: '#6cc', maxValue: 15, type: 'value', field: 'volume' }];// Calculate total usable height and row positionsconst TOTAL_ROW_HEIGHT = ROWS.reduce((sum, row) => sum + row.height + ROW_SPACING, 0);// Initialize canvasconst canvas = document.getElementById('editorCanvas');canvas.width = CANVAS_WIDTH + LABEL_WIDTH;canvas.height = TOTAL_ROW_HEIGHT + SCALE_HEIGHT;const ctx = canvas.getContext('2d');// Value display elementsconst valueDisplay = document.createElement('div');valueDisplay.className = 'panel-section mt-4';valueDisplay.innerHTML = `  <div class="grid grid-cols-6 gap-4">    <div>      <label class="block text-sm font-medium text-gray-400 mb-1">Frame</label>      <input type="number" id="frameInput" min="0" max="255" class="w-full bg-gray-700 border border-gray-600 rounded-md px-2 py-1">    </div>    <div>      <label class="block text-sm font-medium text-gray-400 mb-1">Tone</label>      <input type="number" id="toneInput" min="0" max="4095" class="w-full bg-gray-700 border border-gray-600 rounded-md px-2 py-1">    </div>    <div>      <label class="block text-sm font-medium text-gray-400 mb-1">Noise</label>      <input type="number" id="noiseInput" min="0" max="31" class="w-full bg-gray-700 border border-gray-600 rounded-md px-2 py-1">    </div>    <div>      <label class="block text-sm font-medium text-gray-400 mb-1">Volume</label>      <input type="number" id="volumeInput" min="0" max="15" class="w-full bg-gray-700 border border-gray-600 rounded-md px-2 py-1">    </div>    <div>      <label class="block text-sm font-medium text-gray-400 mb-1">Flags</label>      <div class="flex gap-2">        <label class="inline-flex items-center">          <input type="checkbox" id="tInput" class="form-checkbox">          <span class="ml-1" title="Enable or Disable Tone on active frame">T</span>        </label>        <label class="inline-flex items-center">          <input type="checkbox" id="nInput" class="form-checkbox">          <span class="ml-1" title="Enable or Disable Noise on active frame">N</span>        </label>      </div>    </div>  </div>`;canvas.parentNode.insertBefore(valueDisplay, canvas.nextSibling);let playbackHz = 50; // Par défaut à 50Hz// Get input elementsconst frameInput = document.getElementById('frameInput');const toneInput = document.getElementById('toneInput');const noiseInput = document.getElementById('noiseInput');const volumeInput = document.getElementById('volumeInput');const tInput = document.getElementById('tInput');const nInput = document.getElementById('nInput'); // Variables pour le mode Sélection/Edition    let isSelectionMode = false;    let selectionStart = null;    let selectionEnd = null;    let copiedFrames = null;    let isClearMode = false;    let clearRangeStart = null;    let clearRangeEnd = null;// 1. Gestion améliorée de l'AudioContextlet globalAudioContext = null;let playingSource = null;function initAudioContext() {  if (!globalAudioContext || globalAudioContext.state === 'closed') {    try {      const AudioCtx = window.AudioContext || window.webkitAudioContext;      globalAudioContext = new AudioCtx();    } catch (error) {      console.error('Failed to create AudioContext:', error);      return null;    }  } else if (globalAudioContext.state === 'suspended') {    globalAudioContext.resume();  }  return globalAudioContext;}// 2. Fonction de validation des données audiofunction validateAudioData(frames) {  if (!frames || !Array.isArray(frames) || frames.length === 0) {    console.error('Invalid frames data');    return false;  }    for (const frame of frames) {    if (!frame || typeof frame !== 'object') {      console.error('Invalid frame data');      return false;    }        // Valider et corriger les valeurs    frame.tone = Math.max(0, Math.min(4095, frame.tone || 0));    frame.noise = Math.max(0, Math.min(31, frame.noise || 0));    frame.volume = Math.max(0, Math.min(15, frame.volume || 0));    frame.t = Boolean(frame.t);    frame.n = Boolean(frame.n);  }    return true;}// Créer un seul AudioContext réutilisablefunction getAudioContext() {  if (!globalAudioContext) {    const AudioCtx = window.AudioContext || window.webkitAudioContext;    if (!AudioCtx) {      notifyError("AudioContext not supported.");      return null;    }    globalAudioContext = new AudioCtx();  }  return globalAudioContext;}// Optimisation du piano pour réduire la latencefunction playPianoKey(note, octave) {  const ctx = getAudioContext();  if (!ctx) return;  const tone = noteToTone(note, parseInt(octave, 10));  const volume = parseInt(pianoVolume.value, 10);  const t = pianoSetT.checked;  const n = pianoSetN.checked;  // Création directe d'un oscillateur au lieu de passer par le WAV  const oscillator = ctx.createOscillator();  const gainNode = ctx.createGain();    // Fréquence basée sur le tone  const frequency = 1773400 / (16 * tone);  oscillator.type = 'square';  oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);    // Volume  const normalizedVolume = volTab[volume] / 65535;  gainNode.gain.setValueAtTime(normalizedVolume, ctx.currentTime);    oscillator.connect(gainNode);  gainNode.connect(ctx.destination);    // Démarrage immédiat avec un court decay  oscillator.start();  gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);  oscillator.stop(ctx.currentTime + 0.1);}let progressUpdateInterval = null;function playWav(u8) {  console.log("=== Playing WAV ===");  stopAudio();  const ctx = initAudioContext();  if (!ctx) {    console.error('No audio context');    return;  }  try {    ctx.decodeAudioData(u8.buffer, (buffer) => {      playingSource = ctx.createBufferSource();      playingSource.buffer = buffer;            // Ajuster la vitesse de lecture      const playbackRate = playbackHz / 50;      playingSource.playbackRate.value = playbackRate;            const gainNode = ctx.createGain();      playingSource.connect(gainNode);      gainNode.connect(ctx.destination);            playingSource.start(0);            // Ajuster la durée pour la barre de progression      const adjustedDuration = buffer.duration / playbackRate;      updateProgressBar(ctx, adjustedDuration);            playingSource.onended = () => {        stopAudio();        ayVisualizer.stopVisualization();      };    }, (error) => {      console.error('Error decoding audio data:', error);      notifyError("Error while decoding audio.");    });  } catch (error) {    console.error('Error playing audio:', error);    notifyError("Error during audio playback");  }}// 5. Fonction de mise à jour de la barre de progressionfunction updateProgressBar(ctx, duration) {  const startTime = ctx.currentTime;  const progressBar = document.getElementById("progressBar");    function update() {    if (!ctx || ctx.state === "closed" || !playingSource) {      progressBar.style.width = "0%";      return;    }        const elapsed = ctx.currentTime - startTime;    const percent = Math.min(100, (elapsed / duration) * 100);    progressBar.style.width = percent + "%";        if (elapsed < duration) {      requestAnimationFrame(update);    } else {      progressBar.style.width = "0%";    }  }    update();}function stopAudio() {  if (playingSource) {    try {      playingSource.stop();    } catch (e) {      console.warn('Error stopping audio source:', e);    }    playingSource.disconnect();    playingSource = null;  }    // Réinitialiser la barre de progression  document.getElementById("progressBar").style.width = "0%";    // Arrêter la visualisation  if (ayVisualizer) {    ayVisualizer.stopVisualization();  }}// Nettoyage lors de la fermeture de la pagewindow.addEventListener('beforeunload', () => {  if (globalAudioContext) {    globalAudioContext.close();    globalAudioContext = null;  }});// Function to get row Y positionfunction getRowY(rowIndex) {  let y = SCALE_HEIGHT;  for (let i = 0; i < rowIndex; i++) {    y += ROWS[i].height + ROW_SPACING;  }  return y;}    /******************************************************************     * Banque & FX     ******************************************************************/    function newEffect(name="") {      const fxName = name || lastFxName;      const effect = { name: fxName, frames: [] };      for (let i = 0; i < NUM_FRAMES; i++) {        effect.frames.push({ t: false, n: false, tone: 0, noise: 0, volume: 0 });      }      return effect;    }    const bank = {      effects: [ newEffect("FX 1") ],      selected: 0    };    function getCurrentFrames() {      return bank.effects[bank.selected].frames;    }    /******************************************************************     * UI – FX selection     ******************************************************************/    const fxSelect = document.getElementById("fxSelect");    const fxIndicator = document.getElementById("fxIndicator");    const fxNameInput = document.getElementById("fxName");    function updateFxSelect() {      fxSelect.innerHTML = "";      bank.effects.forEach((fx, i) => {        const option = document.createElement("option");        option.value = i;        option.textContent = fx.name || ("FX " + (i + 1));        if (i === bank.selected) option.selected = true;        fxSelect.appendChild(option);      });      fxIndicator.textContent = "FX: " + (bank.selected + 1) + " / " + bank.effects.length;      fxNameInput.value = bank.effects[bank.selected].name;    }    fxSelect.addEventListener("change", () => {      bank.selected = parseInt(fxSelect.value, 10);      renderAll();      updateFxSelect();    });    fxNameInput.addEventListener("input", (e) => {      bank.effects[bank.selected].name = e.target.value;      lastFxName = e.target.value;      updateFxSelect();    });    updateFxSelect();    /******************************************************************     * Curseur (frame courant)     ******************************************************************/    let cursorIndex = 0; // frame sélectionnée (0..254)  function moveCursor(newIndex) {  if (newIndex < 0) newIndex = 0;  if (newIndex >= NUM_FRAMES) newIndex = NUM_FRAMES - 1;  cursorIndex = newIndex;    // Si on est en mode live, on joue la frame courante if (isLiveMode) {  const frames = getCurrentFrames();  if (frames && frames[cursorIndex]) {    playLiveFrame(frames[cursorIndex]);  }}    updateCursorAnchor();  renderAll();}function disableClearMode() {   // Désactiver le mode Clear    isClearMode = false;    document.getElementById("clearModeBtn").classList.remove('btn-primary');    canvas.classList.remove('clear-mode');}    /******************************************************************     * Canvas & dessin     ******************************************************************/   // const canvas = document.getElementById("editorCanvas");   // const ctx = canvas.getContext("2d");    const colors = ["#c66", "#6c6", "#66c", "#cc6", "#6cc"];  function renderAll() {      const frames = getCurrentFrames();      ctx.fillStyle = '#1a1a1a';      ctx.fillRect(0, 0, canvas.width, canvas.height);      // Échelle      ctx.fillStyle = '#2d2d2d';      ctx.fillRect(LABEL_WIDTH, 0, CANVAS_WIDTH, SCALE_HEIGHT);      ctx.fillStyle = '#666';      ctx.font = '10px monospace';      for (let i = 0; i < NUM_FRAMES; i += 16) {        const xPos = LABEL_WIDTH + i * FRAME_WIDTH;        ctx.fillText(i.toString(), xPos, 15);        ctx.fillRect(xPos, SCALE_HEIGHT - 5, 1, 5);      }      // Lignes de données      ROWS.forEach((row, rowIndex) => {        const yPos = getRowY(rowIndex);        ctx.fillStyle = '#2d2d2d';        ctx.fillRect(0, yPos, canvas.width, row.height);        ctx.fillStyle = '#fff';        ctx.font = '12px monospace';        ctx.fillText(row.name, 5, yPos + row.height / 2 + 4);        ctx.fillStyle = '#000';        ctx.fillRect(LABEL_WIDTH - 1, yPos, 1, row.height);        for (let i = 0; i < NUM_FRAMES; i++) {          const frame = frames[i];          const xPos = LABEL_WIDTH + i * FRAME_WIDTH;          if (row.type === 'toggle') {            ctx.fillStyle = frame[row.field] ? row.color : '#444';            ctx.fillRect(xPos, yPos, FRAME_WIDTH - 1, row.height);          } else {            const value = frame[row.field];            const height = (value / row.maxValue) * row.height;            ctx.fillStyle = row.color;            ctx.fillRect(xPos, yPos + row.height - height, FRAME_WIDTH - 1, height);          }        }      });      // Affichage du curseur      const cursorX = LABEL_WIDTH + cursorIndex * FRAME_WIDTH;      ctx.strokeStyle = '#fff';      ctx.lineWidth = 2;      ctx.beginPath();      ctx.moveTo(cursorX + FRAME_WIDTH / 2, SCALE_HEIGHT);      ctx.lineTo(cursorX + FRAME_WIDTH / 2, canvas.height);      ctx.stroke();      // Mise à jour des inputs      if (!isSelectionMode) {      const currentFrame = frames[cursorIndex];      frameInput.value = cursorIndex;      toneInput.value = currentFrame.tone;      noiseInput.value = currentFrame.noise;      volumeInput.value = currentFrame.volume;      tInput.checked = currentFrame.t;      nInput.checked = currentFrame.n;      }      // Affichage de la sélection en mode Sélection      if (isSelectionMode && selectionStart !== null && selectionEnd !== null) {        const start = Math.min(selectionStart, selectionEnd);        const end = Math.max(selectionStart, selectionEnd);        const xSel = LABEL_WIDTH + start * FRAME_WIDTH;        const selWidth = (end - start + 1) * FRAME_WIDTH;        ctx.fillStyle = 'rgba(255,255,0,0.3)';        ctx.fillRect(xSel, SCALE_HEIGHT, selWidth, canvas.height - SCALE_HEIGHT);      }    }    function drawToggleRow(rowIndex, fieldName, color, frames) {      const y0 = rowIndex * ROW_HEIGHT;      for (let i = 0; i < NUM_FRAMES; i++) {        ctx.fillStyle = frames[i][fieldName] ? color : "#444";        ctx.fillRect(i * COL_WIDTH, y0, COL_WIDTH, ROW_HEIGHT);      }    }    function drawValueRow(rowIndex, fieldName, maxVal, color, frames) {      const y0 = rowIndex * ROW_HEIGHT;      ctx.fillStyle = color;      for (let i = 0; i < NUM_FRAMES; i++) {        const val = frames[i][fieldName];        const fraction = val / maxVal;        const h = Math.round(fraction * ROW_HEIGHT);        ctx.fillRect(i * COL_WIDTH, y0 + (ROW_HEIGHT - h), COL_WIDTH, h);      }    }    function drawCursor() {      ctx.save();      ctx.strokeStyle = "#fff";      ctx.lineWidth = 2;      const x = cursorIndex * COL_WIDTH + COL_WIDTH / 2;      ctx.beginPath();      ctx.moveTo(x, 0);      ctx.lineTo(x, ROW_HEIGHT * NUM_ROWS);      ctx.stroke();      ctx.restore();    }    // Création de l'élément d'ancreconst cursorAnchor = document.createElement('div');cursorAnchor.style.cssText = `  position: absolute;  width: 0;  height: 0;  border-left: 8px solid transparent;  border-right: 8px solid transparent;  border-bottom: 12px solid white;  transform: translateX(-50%);  z-index: 1;  cursor: grab;  user-select: none;`;// Placer l'ancre dans le conteneur principalconst mainContent = document.querySelector('.editor-section');mainContent.style.position = 'relative';mainContent.appendChild(cursorAnchor);// Variables pour le draglet isDragging = false;let startX = 0;let startCursorIndex = 0;function updateCursorAnchor() {  const canvasRect = canvas.getBoundingClientRect();  const mainRect = mainContent.getBoundingClientRect();    const x = canvasRect.left - mainRect.left + LABEL_WIDTH + cursorIndex * FRAME_WIDTH + FRAME_WIDTH/2;  const y = canvasRect.bottom - mainRect.top;    cursorAnchor.style.left = x + 'px';  cursorAnchor.style.top = y + 'px';}// Gestion du drag sur l'ancrecursorAnchor.addEventListener('mousedown', (e) => {  e.preventDefault();  isDragging = true;  startX = e.clientX;  startCursorIndex = cursorIndex;  cursorAnchor.style.cursor = 'grabbing';  document.body.style.userSelect = 'none';});document.addEventListener('mousemove', (e) => {  if (!isDragging) return;  e.preventDefault();    const canvasRect = canvas.getBoundingClientRect();  const dx = e.clientX - startX;  const newFrameOffset = Math.round(dx / FRAME_WIDTH);  const newIndex = Math.max(0, Math.min(NUM_FRAMES - 1, startCursorIndex + newFrameOffset));    if (newIndex !== cursorIndex) {    moveCursor(newIndex);    renderAll();  }});document.addEventListener('mouseup', () => {  if (isDragging) {    isDragging = false;    cursorAnchor.style.cursor = 'grab';    document.body.style.userSelect = '';  }});cursorAnchor.addEventListener('dragstart', (e) => {  e.preventDefault();});// Initialisation de la position de l'ancre// Attendre que le DOM soit complètement chargédocument.addEventListener('DOMContentLoaded', () => {  const copyBtn = document.getElementById("copySelectionBtn");  const pasteBtn = document.getElementById("pasteSelectionBtn");    if (copyBtn) {    copyBtn.disabled = true;    copyBtn.classList.add('opacity-50');  }  if (pasteBtn) {    pasteBtn.disabled = true;    pasteBtn.classList.add('opacity-50');  }  updateCursorAnchor();});// En cas de redimensionnement de la fenêtrewindow.addEventListener('resize', updateCursorAnchor);    renderAll();  // Fonction pour réinitialiser la sélectionfunction clearSelection() {  selectionStart = null;  selectionEnd = null;  // Désactiver uniquement le bouton Copy car il n'y a plus de sélection  document.getElementById("copySelectionBtn").disabled = true;  document.getElementById("copySelectionBtn").classList.add('opacity-50');  // Ne pas toucher au bouton Paste ni au contenu copié  renderAll();}function toggleSelectionMode(enable) {  // Arrêter l'audio et fermer le contexte  stopAudio();  disableClearMode();  if (globalAudioContext) {    globalAudioContext.close();    globalAudioContext = null;  }    isSelectionMode = enable;  const canvas = document.getElementById('editorCanvas');  if (canvas) {    canvas.style.cursor = enable ?       `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='white' stroke='white' stroke-width='1'%3E%3Cpath d='M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z' fill='white'/%3E%3C/svg%3E") 3 3, crosshair`       : 'crosshair';  }  /// 2. Toggle mode icons  const editIcon = document.querySelector('.mode-icon.edit-mode');  const selectionIcon = document.querySelector('.mode-icon.selection-mode');  if (editIcon && selectionIcon) {    editIcon.classList.toggle('hidden', enable);    selectionIcon.classList.toggle('hidden', !enable);  }    const toolbar = document.getElementById('interpolationToolbar');  if (toolbar) {    toolbar.classList.toggle('hidden', !enable);  }  // Liste des IDs des boutons à désactiver en mode sélection  const buttonIds = [    "importWavBtn",    "newFxBtn",    "deleteFxBtn",    "downloadWavBtn",    "downloadAfbBtn",    "copyBtn",    "importBtn",    "pasteFxBtn",    "liveModeBtn",    "loadAfxBtn",    "saveAfxBtn"  ];    function disableLiveMode() {  isLiveMode = false;  document.getElementById("liveModeBtn").classList.remove('btn-primary');  if (currentLiveSource) {    currentLiveSource.stop();    currentLiveSource = null;  }}    // Désactiver/activer les boutons  buttonIds.forEach(id => {    const button = document.getElementById(id);    if (button) {      button.disabled = enable;      // Optionnel : ajouter une classe pour le style disabled      if (enable) {        button.classList.add('opacity-50');      } else {        button.classList.remove('opacity-50');      }    }       });// 4. Handle copy/paste buttons  const copyBtn = document.getElementById("copySelectionBtn");  const pasteBtn = document.getElementById("pasteSelectionBtn");    if (!enable) {    // En mode édition, toujours désactivés    copyBtn.disabled = true;    pasteBtn.disabled = true;    copyBtn.classList.add('opacity-50');    pasteBtn.classList.add('opacity-50');  }  // En mode sélection, on ne les désactive pas ici   // car leur état dépendra de la sélection      if (enable) {          document.getElementById('toneInput').value = '0';          document.getElementById('noiseInput').value = '0';          document.getElementById('volumeInput').value = '0';          document.getElementById('tInput').checked = false;          document.getElementById('nInput').checked = false;                    // Ne pas désactiver ces inputs en mode sélection          document.getElementById('toneInput').disabled = false;          document.getElementById('noiseInput').disabled = false;          document.getElementById('volumeInput').disabled = false;          document.getElementById('tInput').disabled = false;          document.getElementById('nInput').disabled = false;          // Désactive live mode          disableLiveMode()         }    // Désactiver aussi les inputs  const fxName = document.getElementById("fxName");  const fxSelect = document.getElementById("fxSelect");  const fxImportData = document.getElementById("fxImportData");    [fxName, fxSelect, fxImportData].forEach(input => {    if (input) {      input.disabled = enable;      if (enable) {        input.classList.add('opacity-50');      } else {        input.classList.remove('opacity-50');      }    }  });    // Réinitialiser la sélection si on désactive le modeif (!enable) {  selectionStart = null;  selectionEnd = null;  document.getElementById("copySelectionBtn").disabled = true;    // Ne pas désactiver le bouton de collage s'il y a des données copiées  if (copiedFrames === null) {    document.getElementById("pasteSelectionBtn").disabled = true;    document.getElementById("pasteSelectionBtn").classList.add('opacity-50');  } else {    document.getElementById("pasteSelectionBtn").disabled = false;    document.getElementById("pasteSelectionBtn").classList.remove('opacity-50');  }}    renderAll();}    /******************************************************************     * Interaction souris sur le canvas     ******************************************************************/    let isMouseDown = false;    let isRightButtonDown = false;        canvas.addEventListener('contextmenu', (e) => {      e.preventDefault();    });   canvas.addEventListener("mousedown", (e) => {      e.preventDefault();      isMouseDown = true;      isRightButtonDown = (e.button === 2);            // Réinitialiser les variables d'interpolation      lastMouseX = null;      lastMouseY = null;      lastFrameIndex = null;      lastRowIndex = null;      isInterpolationActive = false;            // En mode Sélection, réinitialiser la sélection      if (isSelectionMode) {        selectionStart = null;        selectionEnd = null;        document.getElementById("copySelectionBtn").disabled = true;      }            handleMouse(e, isRightButtonDown);    });    canvas.addEventListener("mousemove", (e) => {        if (isMouseDown) {          handleMouse(e, isRightButtonDown);        }      });   canvas.addEventListener("mouseup", (e) => {  // Réinitialiser les variables d'interpolation  lastMouseX = null;  lastMouseY = null;  lastFrameIndex = null;  lastRowIndex = null;  isInterpolationActive = false;    if (isSelectionMode && selectionStart !== null && selectionEnd !== null) {    document.getElementById("copySelectionBtn").disabled = false;  }    isMouseDown = false;});      canvas.addEventListener("mouseleave", () => {  // Réinitialiser les variables d'interpolation  lastMouseX = null;  lastMouseY = null;  lastFrameIndex = null;  lastRowIndex = null;  isInterpolationActive = false;    isMouseDown = false;});    // Nouveaux écouteurs pour les boutons du mode Sélection/Edition   document.getElementById("toggleSelectionModeBtn").addEventListener("click", () => {  stopAudio();  toggleSelectionMode(!isSelectionMode);  if (isSelectionMode) {    notifyInfo("Selection Mode activated. Click and drag on the canvas to select frames.");     document.getElementById("toggleSelectionModeBtn").classList.add('btn-primary');  } else {    document.getElementById("toggleSelectionModeBtn").classList.remove('btn-primary');  }  });    document.getElementById("copySelectionBtn").addEventListener("click", () => {      stopAudio();      disableClearMode();      if (selectionStart === null || selectionEnd === null) {        notifyError("No selection done");        return;      }      const start = Math.min(selectionStart, selectionEnd);      const end = Math.max(selectionStart, selectionEnd);      const frames = getCurrentFrames();      copiedFrames = frames.slice(start, end + 1).map(frame => ({ ...frame }));      const pasteBtn = document.getElementById("pasteSelectionBtn");      pasteBtn.disabled = false;      pasteBtn.classList.remove('opacity-50');      notifySuccess("Frames copied from index  " + start + " to " + end + ".");      document.getElementById("pasteSelectionBtn").disabled = false;    });    document.getElementById("pasteSelectionBtn").addEventListener("click", () => {      stopAudio();      if (!copiedFrames) {        notifyError("No data copied");        return;      }      const startIndex = cursorIndex;      const frames = getCurrentFrames();      for (let i = 0; i < copiedFrames.length; i++) {        const targetIndex = startIndex + i;        if (targetIndex >= NUM_FRAMES) break;        frames[targetIndex] = { ...copiedFrames[i] };      }      notifySuccess("Pasting " + copiedFrames.length + " frames starting from index " + startIndex + ".");      renderAll();    });  // Handle mouse interactionlet lastMouseX = null;let lastMouseY = null;let lastFrameIndex = null;let lastRowIndex = null;let isInterpolationActive = false;// Fonction principale handleMouse modifiéefunction handleMouse(e, isRightClick = false) {  const rect = canvas.getBoundingClientRect();  const x = e.clientX - rect.left;  const y = e.clientY - rect.top;  if (y < SCALE_HEIGHT || x < LABEL_WIDTH) return;  const frameIndex = Math.floor((x - LABEL_WIDTH) / FRAME_WIDTH);  if (frameIndex < 0 || frameIndex >= NUM_FRAMES) return;    // Déterminer la ligne cliquée  let currentY = SCALE_HEIGHT;  let clickedRow = null;  for (let i = 0; i < ROWS.length; i++) {    const row = ROWS[i];    if (y >= currentY && y < currentY + row.height) {      clickedRow = { ...row, index: i };      break;    }    currentY += row.height + ROW_SPACING;  }  if (!clickedRow) return;    // Mode Clear  if (isClearMode) {    handleClearMode(clickedRow);    return;  }  // Si mode sélection  if (isSelectionMode) {    handleSelectionMode(frameIndex);    return;  }  // Vérifier si nous avons une position précédente et si l'interpolation est active  if (isInterpolationActive && lastMouseX !== null && lastFrameIndex !== null &&       lastRowIndex === clickedRow.index &&       frameIndex !== lastFrameIndex) {        // Interpolation entre les frames    interpolateFrames(lastFrameIndex, frameIndex, clickedRow, lastMouseY, y, isRightClick);  } else {    // Traitement normal pour une seule frame    processFrame(frameIndex, clickedRow, y, isRightClick);  }  // Mettre à jour les dernières positions  lastMouseX = x;  lastMouseY = y;  lastFrameIndex = frameIndex;  lastRowIndex = clickedRow.index;    // Activer l'interpolation après le premier événement  isInterpolationActive = true;}// Fonction pour interpoler les framesfunction interpolateFrames(startIdx, endIdx, row, startY, endY, isRightClick) {  const frames = getCurrentFrames();  const startFrame = Math.min(startIdx, endIdx);  const endFrame = Math.max(startIdx, endIdx);  const direction = startIdx < endIdx ? 1 : -1;    // Calculer le nombre de frames à interpoler  const frameCount = endFrame - startFrame + 1;    // Traiter chaque frame entre les points  for (let i = 0; i < frameCount; i++) {    const frameIdx = startFrame + i;        // Ignorer la frame de départ qui a déjà été traitée    if (frameIdx === startIdx) continue;        // Calculer le facteur d'interpolation    const t = (frameIdx - startFrame) / (endFrame - startFrame);        // Interpoler la position Y pour les valeurs continues    const interpY = startY + (endY - startY) * t;        // Traiter la frame interpolée    if (row.type === 'toggle') {      // Pour les toggles, on applique la même valeur à toutes les frames      frames[frameIdx][row.field] = isRightClick ? false : true;    } else {      // Pour les valeurs, on calcule en fonction de la position Y interpolée      if (isRightClick) {        frames[frameIdx][row.field] = 0;      } else {        const rowY = getRowY(row.index);        const value = Math.round((1 - (interpY - rowY) / row.height) * row.maxValue);        frames[frameIdx][row.field] = Math.max(0, Math.min(row.maxValue, value));      }    }  }    // Déplacer le curseur à la position finale  moveCursor(endIdx);    // Jouer le son si le mode live est actif  if (isLiveMode) {    playLiveFrame(frames[endIdx]);  }    // Mettre à jour l'affichage  renderAll();}// Traiter une frame uniquefunction processFrame(frameIndex, row, y, isRightClick) {  const frames = getCurrentFrames();    // Déplacer le curseur  moveCursor(frameIndex);    // Modifier la valeur de la frame  if (row.type === 'toggle') {    frames[frameIndex][row.field] = isRightClick ? false : true;  } else {    if (isRightClick) {      frames[frameIndex][row.field] = 0;    } else {      const rowY = getRowY(row.index);      const value = Math.round((1 - (y - rowY) / row.height) * row.maxValue);      frames[frameIndex][row.field] = Math.max(0, Math.min(row.maxValue, value));    }  }    // Jouer le son si le mode live est actif  if (isLiveMode) {    playLiveFrame(frames[frameIndex]);  }    // Mettre à jour l'affichage  renderAll();}// Gestion du mode Clearfunction handleClearMode(clickedRow) {  const frames = getCurrentFrames();    if (isSelectionMode && clearRangeStart !== null && clearRangeEnd !== null) {    selectionStart = clearRangeStart;    selectionEnd = clearRangeEnd;    const start = Math.min(clearRangeStart, clearRangeEnd);    const end = Math.max(clearRangeStart, clearRangeEnd);        for (let i = start; i <= end; i++) {      if (clickedRow.type === 'toggle') {        frames[i][clickedRow.field] = false;      } else {        frames[i][clickedRow.field] = 0;      }    }        notifySuccess(`Cleared ${clickedRow.name} data in selected range`);  } else {    for (let i = 0; i < frames.length; i++) {      if (clickedRow.type === 'toggle') {        frames[i][clickedRow.field] = false;      } else {        frames[i][clickedRow.field] = 0;      }    }        notifySuccess(`Cleared all ${clickedRow.name} data`);  }    renderAll();}// Gestion du mode Sélectionfunction handleSelectionMode(frameIndex) {  if (selectionStart === null) {    selectionStart = frameIndex;    selectionEnd = frameIndex;  } else {    selectionEnd = frameIndex;  }    document.getElementById("copySelectionBtn").disabled = false;  document.getElementById("copySelectionBtn").classList.remove('opacity-50');    renderAll();}    /******************************************************************     * Navigation & gestion des FX     ******************************************************************/    function refreshAll() {      updateFxSelect();      renderAll();    }    document.getElementById("prevFxBtn").addEventListener("click", () => {      stopAudio();       disableClearMode();      if (isSelectionMode) {        clearSelection();      }      if (bank.selected > 0) {        bank.selected--;        refreshAll();      }    });    document.getElementById("nextFxBtn").addEventListener("click", () => {      stopAudio();      disableClearMode();      if (isSelectionMode) {        clearSelection();      }      if (bank.selected < bank.effects.length - 1) {        bank.selected++;        refreshAll();      }    });    document.getElementById("newFxBtn").addEventListener("click", () => {      stopAudio();       disableClearMode();           // Récupérer le nom actuel        const currentName = lastFxName || "FX";                // Trouver le numéro le plus élevé dans les noms existants        let maxNumber = 0;        bank.effects.forEach(effect => {          const name = effect.name;          // Utiliser une regex pour extraire le numéro à la fin du nom          const match = name.match(/^(.*?)(\d+)$/);          if (match) {            const num = parseInt(match[2], 10);            if (num > maxNumber) maxNumber = num;          }        });                // Créer le nouveau nom en incrémentant le numéro        const baseName = currentName.replace(/\d+$/, ''); // Enlever les chiffres à la fin        const newName = `${baseName}${maxNumber + 1}`;                // Créer et ajouter le nouvel effet        bank.effects.push(newEffect(newName));        bank.selected = bank.effects.length - 1;        lastFxName = newName;        notifyInfo("New FX added to the bank.");        refreshAll();    });document.getElementById("deleteFxBtn").addEventListener("click", () => {  try {    // Vérification de base des structures de données    if (!bank || !Array.isArray(bank.effects)) {      notifyError("Bank structure is invalid");      return;    }    // Arrêt de l'audio en cours    stopAudio();    disableClearMode();    // Vérification de l'index sélectionné    if (bank.selected < 0 || bank.selected >= bank.effects.length) {      notifyError("Invalid effect selection");      return;    }    const effectName = bank.effects[bank.selected].name || "Unnamed effect";    if (bank.effects.length > 1) {      try {        // Sauvegarde de l'état précédent au cas où        const previousState = [...bank.effects];        const previousSelection = bank.selected;        bank.effects.splice(bank.selected, 1);        bank.selected = Math.max(0, bank.selected - 1);                refreshAll();        notifySuccess(`Effect "${effectName}" removed from the bank`);      } catch (spliceError) {        // En cas d'erreur pendant la suppression, on restaure l'état précédent        bank.effects = previousState;        bank.selected = previousSelection;        notifyError("Failed to remove effect. Please try again");        console.error("Error during effect removal:", spliceError);      }    } else {      // Si c'est le dernier effet, on le réinitialise      try {        bank.effects[0] = newEffect();        refreshAll();        notifyInfo("Last effect reset to default");      } catch (resetError) {        notifyError("Failed to reset last effect");        console.error("Error resetting last effect:", resetError);      }    }  } catch (error) {    // Gestion des erreurs générales    console.error("Critical error in delete FX handler:", error);    notifyError("An unexpected error occurred while deleting the effect");        // Tentative de récupération de l'état    try {      refreshAll();    } catch {      notifyError("Failed to recover bank state. Please reload the page");    }  }});    refreshAll();    /******************************************************************     * AY Emulation & WAV Generation     ******************************************************************/    const AY_CLOCK = 1773400;    let MIX_RATE = 44100;    const volTab = Int32Array.from([      0, 836/3, 1212/3, 1773/3, 2619/3, 3875/3, 5397/3, 8823/3,      10392/3, 16706/3, 23339/3, 29292/3, 36969/3, 46421/3, 55195/3, 65535/3    ]);    class Tone { constructor() { this.count = 0; this.state = 0; } }    class Noise { constructor() { this.count = 0; this.reg = 0xffff; this.qcc = 0; this.state = 0; } }    class Chip {      constructor() {        this.tone = [ new Tone() ];        this.noise = new Noise();        this.reg = new Int32Array(16);        this.dac = new Uint8Array(1);        this.out = 0;        this.freqDiv = 0;      }    }    function ayInit(ay) {      ay.noise.reg = 0xffff;      ay.noise.qcc = 0;      ay.noise.state = 0;    }    function ayTick(ay, ticks) {      let noise_di;      ay.out = 0;      for (let aa = 0; aa < ticks; aa++) {        ay.freqDiv ^= 1;        if (ay.tone[0].count >= (ay.reg[0] | (ay.reg[1] << 8))) {          ay.tone[0].count = 0;          ay.tone[0].state ^= 1;        }        ay.tone[0].count++;        if (ay.freqDiv) {          if (ay.noise.count === 0) {            noise_di = ay.noise.qcc ^ ((ay.noise.reg >> 13) & 1) ^ 1;            ay.noise.qcc = (ay.noise.reg >> 15) & 1;            ay.noise.state = ay.noise.qcc;            ay.noise.reg = (ay.noise.reg << 1) | noise_di;          }          ay.noise.count = (ay.noise.count + 1) & 31;          if (ay.noise.count >= ay.reg[6]) { ay.noise.count = 0; }        }        let ta = ay.tone[0].state | ((ay.reg[7] >> 0) & 1);        let na = ay.noise.state | ((ay.reg[7] >> 3) & 1);        if (ta & na) { ay.dac[0] = ay.reg[8]; } else { ay.dac[0] = 0; }        ay.out += volTab[ay.dac[0]];      }    }    function ayOut(ay, reg, value) {      switch (reg) {        case 1: value &= 15; break;        case 0:        case 7: break;        case 8:        case 6: value &= 31; break;      }      ay.reg[reg] = value;    }      function createAYWaveFromFrames(frames, forExport = false) {        // Sauvegarder temporairement le mode sélection        const wasInSelectionMode = isSelectionMode;        try {          // Désactiver temporairement le mode sélection pour la génération audio          isSelectionMode = false;                    // Récupérer les paramètres d'export          const sampleRateSelect = document.getElementById('sampleRateSelect');          const exportFormatSelect = document.getElementById('exportFormatSelect');          const exportFormat = exportFormatSelect ? exportFormatSelect.value : 'wav';          const sampleRate = sampleRateSelect ? parseInt(sampleRateSelect.value, 10) : 44100;                    // Si on exporte en PCM 8 bits (sans entête) ET que c'est pour l'export          if (forExport && (exportFormat === 'pcm' || exportFormat === 'adpcm')) {            if (exportFormat === 'adpcm') {              // Créer une copie des données pour éviter les problèmes de propriété readonly              const data = createAYADPCM4bit(frames, sampleRate);              return new Uint8Array(data);            } else {              return createAYPCM8bit(frames, sampleRate);            }          }                    // Export en WAV standard (utilisé aussi pour la lecture)          const frameCount = frames.length;        const ifrq = Math.floor(sampleRate / playbackHz);// Utiliser la fréquence variable        const totalSamples = Math.floor(ifrq * frameCount);        const flen = 44 + totalSamples * 2;        const data = new Uint8Array(flen);        const view = new DataView(data.buffer);                writeString(view, 0, "RIFF");        view.setUint32(4, flen - 8, true);        writeString(view, 8, "WAVEfmt ");        view.setUint32(16, 16, true);        view.setUint16(20, 1, true);        view.setUint16(22, 1, true);        view.setUint32(24, sampleRate, true);        view.setUint32(28, sampleRate * 2, true);        view.setUint16(32, 2, true);        view.setUint16(34, 16, true);        writeString(view, 36, "data");        view.setUint32(40, totalSamples * 2, true);                const ay = new Chip();        ayInit(ay);                // Ajuster le tick en fonction du taux d'échantillonnage        const tick = (AY_CLOCK / 8 / sampleRate) | 0;        let sampleIndex = 0;                for (let f = 0; f < frameCount; f++) {          const fr = frames[f];          ayOut(ay, 0, fr.tone & 0xff);          ayOut(ay, 1, fr.tone >> 8);          ayOut(ay, 6, fr.noise);          let mixer = 0xf6;          if (!fr.t) mixer |= 1;          if (!fr.n) mixer |= 8;          ayOut(ay, 7, mixer);          ayOut(ay, 8, fr.volume);                    for (let i = 0; i < ifrq; i++) {            ayTick(ay, tick);            const val = (ay.out / tick) | 0;            view.setInt16(44 + sampleIndex * 2, val, true);            sampleIndex++;          }        }                return data;      } finally {        // Restaurer le mode sélection à son état d'origine        isSelectionMode = wasInSelectionMode;      }    }      // Fonction pour créer de l'ADPCM 4 bits (sans entête)   function createAYADPCM4bit(frames, sampleRate) {  // Génération des échantillons PCM 16-bit signés  const frameCount = frames.length;  const ifrq = sampleRate / playbackHz;  const totalSamples = Math.floor(ifrq * frameCount);  const pcmSamples = new Int16Array(totalSamples);    const ay = new Chip();  ayInit(ay);    // Ajuster le tick en fonction du taux d'échantillonnage  const tick = (AY_CLOCK / 8 / sampleRate) | 0;  let sampleIndex = 0;    // Générer les échantillons PCM 16-bits  for (let f = 0; f < frameCount; f++) {    const fr = frames[f];    ayOut(ay, 0, fr.tone & 0xff);    ayOut(ay, 1, fr.tone >> 8);    ayOut(ay, 6, fr.noise);    let mixer = 0xf6;    if (!fr.t) mixer |= 1;    if (!fr.n) mixer |= 8;    ayOut(ay, 7, mixer);    ayOut(ay, 8, fr.volume);        for (let i = 0; i < ifrq; i++) {      ayTick(ay, tick);      const val = (ay.out / tick) | 0;      pcmSamples[sampleIndex++] = val;    }  }    // Initialiser le tableau ADPCM avec des zéros  const outputSize = Math.ceil(pcmSamples.length / 2);  const adpcmData = new Uint8Array(outputSize);    // Encoder en ADPCM 4-bits (algorithme IMA ADPCM simplifié)  let index = 0;         // Index de step size dans la table  let predictor = 0;     // Valeur prédite    // Table des pas de quantification pour IMA ADPCM  const stepSizeTable = [    7, 8, 9, 10, 11, 12, 13, 14,    16, 17, 19, 21, 23, 25, 28, 31,    34, 37, 41, 45, 50, 55, 60, 66,    73, 80, 88, 97, 107, 118, 130, 143,    157, 173, 190, 209, 230, 253, 279, 307,    337, 371, 408, 449, 494, 544, 598, 658,    724, 796, 876, 963, 1060, 1166, 1282, 1411,    1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024,    3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484,    7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,    15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,    32767  ];    // Table des indices pour l'adaptation du step size  const indexTable = [    -1, -1, -1, -1, 2, 4, 6, 8,    -1, -1, -1, -1, 2, 4, 6, 8  ];    // Encodage des échantillons par paires pour créer des octets complets  for (let i = 0; i < pcmSamples.length; i += 2) {    // Traiter le premier échantillon (nibble supérieur)    const diff1 = pcmSamples[i] - predictor;    const sign1 = diff1 < 0 ? 8 : 0;    let delta1 = Math.abs(diff1);  // Passage de const à let        let tempStep1 = stepSizeTable[index];    let nibble1 = 0;        for (let mask = 4; mask > 0; mask >>= 1) {      if (delta1 >= tempStep1) {        nibble1 |= mask;        delta1 -= tempStep1;      }      tempStep1 >>= 1;    }        const finalNibble1 = nibble1 | sign1;        // Mettre à jour l'état pour le prochain échantillon    index += indexTable[finalNibble1];    index = Math.max(0, Math.min(index, 88));        const sign_bit1 = sign1 ? -1 : 1;    const step_magnitude1 = (((finalNibble1 & 7) * 2 + 1) * stepSizeTable[index]) / 8;    predictor += sign_bit1 * step_magnitude1;    predictor = Math.max(-32768, Math.min(32767, predictor));        // Préparer l'octet (pour l'instant, seulement le nibble supérieur)    let dataByte = (finalNibble1 << 4) & 0xF0;        // Traiter le deuxième échantillon (nibble inférieur), s'il existe    if (i + 1 < pcmSamples.length) {      const diff2 = pcmSamples[i + 1] - predictor;      const sign2 = diff2 < 0 ? 8 : 0;      let delta2 = Math.abs(diff2);  // Passage de const à let            let tempStep2 = stepSizeTable[index];      let nibble2 = 0;            for (let mask = 4; mask > 0; mask >>= 1) {        if (delta2 >= tempStep2) {          nibble2 |= mask;          delta2 -= tempStep2;        }        tempStep2 >>= 1;      }            const finalNibble2 = nibble2 | sign2;            // Mettre à jour l'état pour le prochain échantillon      index += indexTable[finalNibble2];      index = Math.max(0, Math.min(index, 88));            const sign_bit2 = sign2 ? -1 : 1;      const step_magnitude2 = (((finalNibble2 & 7) * 2 + 1) * stepSizeTable[index]) / 8;      predictor += sign_bit2 * step_magnitude2;      predictor = Math.max(-32768, Math.min(32767, predictor));            // Compléter l'octet avec le nibble inférieur      dataByte |= finalNibble2 & 0x0F;    }        // Enregistrer l'octet complet    const byteIndex = Math.floor(i / 2);    if (byteIndex < adpcmData.length) {      adpcmData[byteIndex] = dataByte;    }  }    // Retourne une copie du tableau pour s'assurer qu'il soit writable  return new Uint8Array(adpcmData);}    // fonction pour créer du PCM 8 bits (sans entête)    function createAYPCM8bit(frames, sampleRate) {      const frameCount = frames.length;      const ifrq = sampleRate / playbackHz;      const totalSamples = Math.floor(ifrq * frameCount);      const data = new Uint8Array(totalSamples);            const ay = new Chip();      ayInit(ay);            // Ajuster le tick en fonction du taux d'échantillonnage      const tick = (AY_CLOCK / 8 / sampleRate) | 0;      let sampleIndex = 0;            for (let f = 0; f < frameCount; f++) {        const fr = frames[f];        ayOut(ay, 0, fr.tone & 0xff);        ayOut(ay, 1, fr.tone >> 8);        ayOut(ay, 6, fr.noise);        let mixer = 0xf6;        if (!fr.t) mixer |= 1;        if (!fr.n) mixer |= 8;        ayOut(ay, 7, mixer);        ayOut(ay, 8, fr.volume);                for (let i = 0; i < ifrq; i++) {          ayTick(ay, tick);          // Conversion en 8 bits non signé (0-255)          // On divise par un facteur plus élevé pour éviter l'écrêtage          const val = Math.max(0, Math.min(255, 128 + ((ay.out / tick) / 512)));          data[sampleIndex++] = Math.round(val);        }      }            return data;    }    function writeString(view, offset, str) {      for (let i = 0; i < str.length; i++) {        view.setUint8(offset + i, str.charCodeAt(i));      }    }// Fonction pour mettre à jour le tooltip du bouton d'export en fonction du format sélectionnéfunction updateExportButtonTooltip() {  const exportFormatSelect = document.getElementById('exportFormatSelect');  const downloadWavBtn = document.getElementById('downloadWavBtn');    if (!exportFormatSelect || !downloadWavBtn) return;    const selectedFormat = exportFormatSelect.value;  let tooltipText = '';    switch (selectedFormat) {    case 'wav':      tooltipText = 'Export FX as WAV audio file';      break;    case 'pcm':      tooltipText = 'Export FX as PCM 8-bit raw data';      break;    case 'adpcm':      tooltipText = 'Export FX as ADPCM 4-bit compressed data';      break;    default:      tooltipText = 'Export FX as audio file';  }    // Mettre à jour l'attribut data-tooltip  downloadWavBtn.setAttribute('data-tooltip', tooltipText);}    /******************************************************************     * downloadFile     ******************************************************************/    function downloadFile(data, filename, mime) {      const blob = new Blob([data], { type: mime });      const url = URL.createObjectURL(blob);      const a = document.createElement("a");      a.href = url;      a.download = filename;      a.click();      URL.revokeObjectURL(url);    }    /******************************************************************     * Import/Export de la banque (.afb) – Format original     ******************************************************************/    function exportEffect(effect) {      // Longueur effective (jusqu'à la dernière frame dont le volume est non nul)      let effectiveLength = 1;      for (let i = 0; i < effect.frames.length; i++) {        if (effect.frames[i].volume !== 0) {          effectiveLength = i + 1;        }      }      const maxSize = 0x1000 * 4;      const data = new Uint8Array(maxSize);      let tone = 0, noise = 0;      let ptr = 0;      for (let i = 0; i < effectiveLength; i++) {        const fr = effect.frames[i];        let it = fr.volume & 0x0f;        it |= fr.t ? 0 : 1 << 4;        it |= fr.n ? 0 : 1 << 7;        if (fr.tone !== tone) {          tone = fr.tone;          it |= 1 << 5;        }        if (fr.noise !== noise) {          noise = fr.noise;          it |= 1 << 6;        }        data[ptr++] = it;        if (it & (1 << 5)) {          data[ptr++] = tone & 0xff;          data[ptr++] = (tone >> 8) & 0xff;        }        if (it & (1 << 6)) {          data[ptr++] = noise & 0x1f;        }      }      data[ptr++] = 0xd0;      data[ptr++] = 0x20;      return data.slice(0, ptr);    }    function exportAfb() {      // Exporte la banque entière      const nbFx = bank.effects.length;      const effectsData = [];      let totalSize = 1 + 2 * nbFx;      for (let i = 0; i < nbFx; i++) {        const fx = bank.effects[i];        const effData = exportEffect(fx);        let nameData = null;        if (fx.name && fx.name.length) {          nameData = new TextEncoder().encode(fx.name);        }        effectsData.push({ effData, nameData });        totalSize += effData.length;        if (nameData) {          totalSize += nameData.length + 1;        }      }      const buffer = new Uint8Array(totalSize);      buffer[0] = nbFx;      let pp = 1 + 2 * nbFx;      for (let i = 0; i < nbFx; i++) {        let offset = pp - i * 2 - 2;        buffer[1 + i * 2] = offset & 0xff;        buffer[1 + i * 2 + 1] = (offset >> 8) & 0xff;        buffer.set(effectsData[i].effData, pp);        pp += effectsData[i].effData.length;        if (effectsData[i].nameData) {          buffer.set(effectsData[i].nameData, pp);          pp += effectsData[i].nameData.length;          buffer[pp++] = 0;        }      }      return buffer.slice(0, pp);    }    // Fonction d'import reprise d'une version précédente    function importAfb(u8) {      const view = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);      const nbFx = view.getUint8(0);      const offsets = [];      // Calculer les offsets comme dans le code original      for (let i = 0; i < nbFx; i++) {        let off = view.getUint16(1 + i * 2, true) + 2 + i * 2;        offsets.push(off);      }      const effects = [];      for (let i = 0; i < nbFx; i++) {        const start = offsets[i];        const end = (i < nbFx - 1) ? offsets[i + 1] : u8.length;        const effectData = u8.slice(start, end);        const effect = loadEffectOriginal(effectData);        effects.push(effect);      }      return effects;    }    function loadEffectOriginal(u8) {      const view = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);      let offset = 0;      const framesArr = [];      while (offset < u8.length) {        const byte = view.getUint8(offset++);        if (byte === 0xd0) {          const noiseByte = view.getUint8(offset++);          if (noiseByte >= 0x20) break;        }        let tone = 0, noise = 0;        if (byte & (1 << 5)) {          tone = view.getUint16(offset, true) & 0xfff;          offset += 2;        }        if (byte & (1 << 6)) {          noise = view.getUint8(offset++);          noise &= 0x1f;        }        const frame = {          volume: byte & 0x0f,          t: !(byte & (1 << 4)),          n: !(byte & (1 << 7)),          tone: tone,          noise: noise        };        framesArr.push(frame);      }      // Compléter ou tronquer pour avoir exactement 255 frames      while (framesArr.length < NUM_FRAMES) {        framesArr.push({ t: false, n: false, tone: 0, noise: 0, volume: 0 });      }      if (framesArr.length > NUM_FRAMES) {        framesArr.length = NUM_FRAMES;      }      let name = "";      if (offset < u8.length) {        name = new TextDecoder().decode(u8.slice(offset, u8.length - 1));      }      return { name, frames: framesArr };    }    /******************************************************************     * COPY (Single FX) et Import Single FX     ******************************************************************/    function exportSingleFX(effect) {      const effData = exportEffect(effect);      let arr = [];      for (let i = 0; i < effData.length; i++) {        arr.push(effData[i]);      }      if (effect.name && effect.name.length) {        const nameData = new TextEncoder().encode(effect.name);        for (let i = 0; i < nameData.length; i++) {          arr.push(nameData[i]);        }        arr.push(0);      }      return new Uint8Array(arr);    }    function importSingleFX(u8) {      return loadEffectOriginal(u8);    }    /******************************************************************     * downloadFile     ******************************************************************/    function downloadFile(data, filename, mime) {      const blob = new Blob([data], { type: mime });      const url = URL.createObjectURL(blob);      const a = document.createElement("a");      a.href = url;      a.download = filename;      a.click();      URL.revokeObjectURL(url);    }    /******************************************************************     * Boutons     ******************************************************************/   document.getElementById("playBtn").addEventListener("click", () => {    disableClearMode();  try {    const currentFrames = getCurrentFrames();    if (!currentFrames) {      console.error('No frames available');      return;    }        const wave = createAYWaveFromFrames(currentFrames, false);    if (wave && wave.length > 0) {      playWav(wave);            // Si nous sommes en mode sélection, mettre à jour la visualisation correctement      if (isSelectionMode && ayVisualizer) {        // Assurez-vous que la visualisation fonctionne en mode sélection        ayVisualizer.startVisualization(currentFrames);      }    }  } catch (error) {    console.error('Error playing audio:', error);    notifyError("Audio read error");  }});   // Download WAV/PCML/ADPCM event handler     document.getElementById("downloadWavBtn").addEventListener("click", () => {  disableClearMode();  stopAudio();            const exportFormatSelect = document.getElementById('exportFormatSelect');  const exportFormat = exportFormatSelect ? exportFormatSelect.value : 'wav';  const sampleRate = parseInt(document.getElementById('sampleRateSelect').value, 10);  const currentEffect = bank.effects[bank.selected];  const baseName = currentEffect.name || "effect";            switch(exportFormat) {    case 'pcm':      const pcmData = createAYPCM8bit(getCurrentFrames(), sampleRate);      downloadFile(pcmData, `${baseName}.pcm`, "application/octet-stream");      notifySuccess(`Exported as ${baseName}.pcm (PCM 8-bit)`);      break;            case 'adpcm':      try {        const adpcmData = createAYADPCM4bit(getCurrentFrames(), sampleRate);        // Créer une copie des données pour s'assurer qu'elles sont manipulables        const adpcmCopy = new Uint8Array(adpcmData.length);        adpcmCopy.set(adpcmData);        downloadFile(adpcmCopy, `${baseName}.4pcm`, "application/octet-stream");        notifySuccess(`Exported as ${baseName}.4pcm (ADPCM 4-bit)`);      } catch (error) {        console.error("Error during ADPCM export:", error);        notifyError(`ADPCM export failed: ${error.message}`);      }      break;          default: // 'wav'      const wave = createAYWaveFromFrames(getCurrentFrames(), true); // true = pour export      downloadFile(wave, `${baseName}.wav`, "audio/wav");      notifySuccess(`Exported as ${baseName}.wav (WAV Standard)`);  }});    document.getElementById("downloadAfbBtn").addEventListener("click", () => {      stopAudio();      const data = exportAfb();      downloadFile(data, "bank.afb", "application/octet-stream");    });    document.getElementById("copyBtn").addEventListener("click", () => {      stopAudio();      const fx = bank.effects[bank.selected];      const singleData = exportSingleFX(fx);      const arr = Array.from(singleData);      navigator.clipboard.writeText(arr.join(","))        .then(() => notifySuccess("Current FX copied to clipboard!"));    });    const importFileInput = document.getElementById("importFile");    document.getElementById("importBtn").addEventListener("click", () => {      stopAudio();      importFileInput.click();    });importFileInput.addEventListener("change", (e) => {  stopAudio();  const file = e.target.files[0];  if (!file) return;  const reader = new FileReader();  reader.onload = function(ev) {    const u8 = new Uint8Array(ev.target.result);    const importedEffects = importAfb(u8);    if (importedEffects) {      // Arrêter l'audio et réinitialiser le contexte      stopAudio();      if (globalAudioContext) {        globalAudioContext.close();        globalAudioContext = null;      }            bank.effects = importedEffects;      bank.selected = 0;      updateFxSelect();      renderAll();      notifySuccess("Bank imported with " + importedEffects.length + " FX.");    }  };  reader.readAsArrayBuffer(file);});    /******************************************************************     * Piano Input     ******************************************************************/    const noteFreqMap = {      "C": 261.63, "C#": 277.18, "D": 293.66, "D#": 311.13, "E": 329.63,      "F": 349.23, "F#": 369.99, "G": 392.00, "G#": 415.30, "A": 440.00,      "A#": 466.16, "B": 493.88    };    function noteToTone(note, octave) {      const baseFreq = noteFreqMap[note];      if (!baseFreq) return 0;      const freq = baseFreq * Math.pow(2, (octave - 4));      let period = Math.floor((1773400 / (16 * freq)));      if (period < 0) period = 0;      if (period > 4095) period = 4095;      return period;    }    const octaveSelect = document.getElementById("octaveSelect");    const pianoVolume = document.getElementById("pianoVolume");    const pianoSetT = document.getElementById("pianoSetT");    const pianoSetN = document.getElementById("pianoSetN");    document.querySelectorAll(".piano-keys button").forEach(btn => {      btn.addEventListener("click", (e) => {        const note = e.target.dataset.note;        const octave = parseInt(octaveSelect.value, 10);        const tone = noteToTone(note, octave);        const frames = getCurrentFrames();        frames[cursorIndex].tone = tone;        frames[cursorIndex].t = pianoSetT.checked;        frames[cursorIndex].n = pianoSetN.checked;        frames[cursorIndex].volume = parseInt(pianoVolume.value, 10);        // Avance automatiquement d'une frame après saisie via le piano        moveCursor(cursorIndex + 1);        renderAll();      });    });    /******************************************************************     * Import "Paste FX data" (Single FX)     ******************************************************************/   document.getElementById("pasteFxBtn").addEventListener("click", () => {  const text = fxImportData.value.trim();  if (!text) return;  const parts = text.split(",");  const arr = parts.map(x => parseInt(x, 10));  if (!arr.length) {    notifyError("No data to load");    return;  }  const u8 = new Uint8Array(arr);  const effect = importSingleFX(u8);  if (!effect) {    notifyError("Failed to load effect data");    return;  }  // Arrêter l'audio et réinitialiser le contexte  stopAudio();  if (globalAudioContext) {    globalAudioContext.close();    globalAudioContext = null;  }  bank.effects[bank.selected] = effect;  updateFxSelect();  renderAll();  notifySuccess("Imported data into current FX.");});   // Add mouse event listeners// Add mouse event listeners//canvas.addEventListener('mousedown', (e) => {//  e.preventDefault(); // Empêcher le menu contextuel par défaut//  isMouseDown = true;//  handleMouse(e, e.button === 2); // button 2 est le clic droit//});// Désactiver le menu contextuel sur le canvas//canvas.addEventListener('mousedown', (e) => {//  e.preventDefault(); // Empêcher le menu contextuel par défaut // isMouseDown = true; // isRightButtonDown = (e.button === 2); // handleMouse(e, isRightButtonDown);//});canvas.addEventListener('mousemove', (e) => {  if (isMouseDown) {    const rect = canvas.getBoundingClientRect();    const y = e.clientY - rect.top;        // On permet maintenant le glissement sur T/N avec le bouton droit    if (!isRightButtonDown && y >= SCALE_HEIGHT && y < getRowY(2)) {      return; // On ignore le glissement uniquement pour le clic gauche    }        handleMouse(e, isRightButtonDown);  }});canvas.addEventListener('mouseup', () => { isMouseDown = false; });canvas.addEventListener('mouseleave', () => { isMouseDown = false; });// Handle input changesfunction updateFromInputs(event) {  if (isSelectionMode && selectionStart !== null && selectionEnd !== null) {    const frames = getCurrentFrames();    const start = Math.min(selectionStart, selectionEnd);    const end = Math.max(selectionStart, selectionEnd);        // Identifier quel input a changé via l'ID de l'événement    const changedInput = event.target.id;        // Appliquer uniquement le paramètre modifié    for(let i = start; i <= end; i++) {      switch(changedInput) {        case 'toneInput':          frames[i].tone = Math.min(4095, Math.max(0, parseInt(toneInput.value) || 0));          break;        case 'noiseInput':          frames[i].noise = Math.min(31, Math.max(0, parseInt(noiseInput.value) || 0));          break;        case 'volumeInput':          frames[i].volume = Math.min(15, Math.max(0, parseInt(volumeInput.value) || 0));          break;        case 'tInput':          frames[i].t = tInput.checked;          break;        case 'nInput':          frames[i].n = nInput.checked;          break;      }    }  } else {    // Mode normal - un seul frame    const frames = getCurrentFrames();    const frame = frames[cursorIndex];    const changedInput = event.target.id;        switch(changedInput) {      case 'toneInput':        frame.tone = Math.min(4095, Math.max(0, parseInt(toneInput.value) || 0));        break;      case 'noiseInput':        frame.noise = Math.min(31, Math.max(0, parseInt(noiseInput.value) || 0));        break;      case 'volumeInput':        frame.volume = Math.min(15, Math.max(0, parseInt(volumeInput.value) || 0));        break;      case 'tInput':        frame.t = tInput.checked;        break;      case 'nInput':        frame.n = nInput.checked;        break;    }  }  renderAll();}frameInput.addEventListener('change', () => {  moveCursor(Math.min(255, Math.max(0, parseInt(frameInput.value) || 0)));  renderAll();});toneInput.addEventListener('change', updateFromInputs);noiseInput.addEventListener('change', updateFromInputs);volumeInput.addEventListener('change', updateFromInputs);tInput.addEventListener('change', updateFromInputs);nInput.addEventListener('change', updateFromInputs);// Initial renderrenderAll();////////////:class AYWaveVisualizer {  constructor() {    this.createVisualizer();    this.analyser = null;    this.noiseAnalyser = null;    this.isPlaying = false;    this.animationFrame = null;    this.noiseBuffer = new Float32Array(1024);    this.noisePhase = 0;    this.playbackInterval = null; // Ajout d'une référence à l'intervalle  }  createVisualizer() {    const container = document.createElement('div');    container.className = 'panel-section';    container.innerHTML = `      <h3 class="text-white font-semibold mb-3">Waveform Visualizer</h3>      <div class="flex flex-col gap-2">        <div>          <div class="flex justify-between items-center mb-1">            <label class="text-sm text-gray-400">Tone Waveform</label>            <span id="toneInfo" class="text-sm text-gray-400">T: off | Tone: 0 | Vol: 0</span>          </div>          <canvas id="waveformCanvas" class="w-full bg-gray-800 rounded-lg" height="100"></canvas>        </div>        <div>          <div class="flex justify-between items-center mb-1">            <label class="text-sm text-gray-400">Noise Pattern</label>            <span id="noiseInfo" class="text-sm text-gray-400">N: off | Noise: 0</span>          </div>          <canvas id="noiseCanvas" class="w-full bg-gray-800 rounded-lg" height="60"></canvas>        </div>      </div>    `;    // Insertion après la section Import FX    const leftPanel = document.querySelector('.left-panel');    const importFxSection = leftPanel.querySelector('.import-fx-data').closest('.panel-section');    leftPanel.insertBefore(container, importFxSection.nextSibling);    this.waveformCanvas = document.getElementById('waveformCanvas');    this.noiseCanvas = document.getElementById('noiseCanvas');    this.toneInfo = document.getElementById('toneInfo');    this.noiseInfo = document.getElementById('noiseInfo');        this.resizeCanvases();  }  resizeCanvases() {    [this.waveformCanvas, this.noiseCanvas].forEach(canvas => {      if (canvas) {        canvas.width = canvas.offsetWidth;        const ctx = canvas.getContext('2d');        ctx.imageSmoothingEnabled = false;      }    });  }  generateToneWaveform(frame) {  const samples = new Float32Array(1024);    if (frame.tone > 0 && frame.t) {    const frequency = 1773400 / (16 * frame.tone);    const samplesPerCycle = 44100 / frequency;        // Amplification du volume pour la visualisation    const normalizedVolume = (frame.volume / 15) * 0.95; // Utilisation d'une échelle linéaire pour la visualisation        // Paramètres pour la pente - augmentés pour plus de visibilité    const slopeWidth = samplesPerCycle * 0.15; // 15% du cycle        for (let i = 0; i < samples.length; i++) {      const cyclePosition = (i % samplesPerCycle) / samplesPerCycle;            if (cyclePosition < 0.5) {        // Transition montante        if (cyclePosition < 0.15) {          // Pente montante plus prononcée          samples[i] = (cyclePosition / 0.15) * normalizedVolume;        } else {          samples[i] = normalizedVolume;        }      } else {        // Transition descendante        if (cyclePosition > 0.5 && cyclePosition < 0.65) {          // Pente descendante plus prononcée          samples[i] = (1 - ((cyclePosition - 0.5) / 0.15)) * normalizedVolume;        } else {          samples[i] = -normalizedVolume;        }      }    }  }    return samples;}  generateNoisePattern(frame) {    if (!frame.n || frame.noise === 0) {      this.noiseBuffer.fill(0);      return this.noiseBuffer;    }    let reg = 0x1ffff;    const samples = new Float32Array(1024);    for (let i = 0; i < samples.length; i++) {      samples[i] = (reg & 0x10000) ? 1.0 : -1.0;      const feedback = ((reg & 0x10000) >> 16) ^ ((reg & 0x2000) >> 13);      reg = ((reg << 1) | feedback) & 0x1ffff;      if (i % (frame.noise + 1) === 0) {        reg = (reg * 2 + 1) & 0x1ffff;      }    }    return samples;  }  drawWaveform(frame) {  if (!this.waveformCanvas) return;    const canvas = this.waveformCanvas;  const ctx = canvas.getContext('2d');  const width = canvas.width;  const height = canvas.height;    // Fond  ctx.fillStyle = '#1a1a1a';  ctx.fillRect(0, 0, width, height);    // Grille  ctx.strokeStyle = '#333';  ctx.lineWidth = 0.5;  ctx.beginPath();    // Grille verticale  for (let x = 0; x < width; x += 50) {    ctx.moveTo(x, 0);    ctx.lineTo(x, height);  }    // Grille horizontale  for (let y = 0; y < height; y += height/4) {    ctx.moveTo(0, y);    ctx.lineTo(width, y);  }  ctx.stroke();    // Ligne centrale  ctx.strokeStyle = '#444';  ctx.lineWidth = 1;  ctx.beginPath();  ctx.moveTo(0, height / 2);  ctx.lineTo(width, height / 2);  ctx.stroke();    if (!frame.t || frame.volume === 0) {    // Si pas de tone ou volume 0, dessiner une ligne au centre    ctx.beginPath();    ctx.strokeStyle = '#66c';    ctx.lineWidth = 2;    ctx.moveTo(0, height / 2);    ctx.lineTo(width, height / 2);    ctx.stroke();    return;  }    const samples = this.generateToneWaveform(frame);    // Facteur d'amplification pour la visualisation  const amplification = 0.8; // Utilise 80% de la hauteur disponible    ctx.beginPath();  ctx.strokeStyle = '#66c';  ctx.lineWidth = 2;    for (let i = 0; i < width; i++) {    const sampleIndex = Math.floor((i / width) * samples.length);    const y = (height / 2) * (1 - samples[sampleIndex] * amplification);        if (i === 0) {      ctx.moveTo(i, y);    } else {      ctx.lineTo(i, y);    }  }    // Dessin principal  ctx.stroke();    // Effet de glow  ctx.strokeStyle = 'rgba(102, 102, 224, 0.3)';  ctx.lineWidth = 4;  ctx.stroke();}drawNoise(frame) {    if (!this.noiseCanvas) return;    const canvas = this.noiseCanvas;    const ctx = canvas.getContext('2d');    const width = canvas.width;    const height = canvas.height;    ctx.fillStyle = '#1a1a1a';    ctx.fillRect(0, 0, width, height);    const noiseSamples = this.generateNoisePattern(frame);    const volume = frame.volume / 15;    ctx.beginPath();    ctx.strokeStyle = '#cc6';    ctx.lineWidth = 2;        for (let i = 0; i < width; i++) {      const sampleIndex = Math.floor((i / width) * noiseSamples.length);      const y = (height / 2) * (1 - noiseSamples[sampleIndex] * volume);      if (i === 0) {        ctx.moveTo(i, y);      } else {        ctx.lineTo(i, y);      }    }    ctx.stroke();  }  updateInfo(frame) {    // Mise à jour des informations de tone    const toneFreq = frame.tone > 0 ? Math.round(1773400 / (16 * frame.tone)) : 0;    this.toneInfo.textContent = `T: ${frame.t ? 'on' : 'off'} | Tone: ${frame.tone} (${toneFreq}Hz) | Vol: ${frame.volume}`;        // Mise à jour des informations de noise    this.noiseInfo.textContent = `N: ${frame.n ? 'on' : 'off'} | Noise: ${frame.noise}`;  }  update(frame) {    if (!frame) return;    this.updateInfo(frame);    this.drawWaveform(frame);    this.drawNoise(frame);  } startVisualization(frames) {    this.stopVisualization(); // Arrête toute visualisation en cours        if (!frames || frames.length === 0) return;        let frameIndex = 0;    this.isPlaying = true;        // Stocke la référence de l'intervalle pour pouvoir l'arrêter plus tard    this.playbackInterval = setInterval(() => {      if (!this.isPlaying) {        this.stopVisualization();        return;      }      this.update(frames[frameIndex]);      frameIndex = (frameIndex + 1) % frames.length;    }, 20); // 50fps  }  stopVisualization() {    this.isPlaying = false;        // Arrêt de l'intervalle de lecture    if (this.playbackInterval) {      clearInterval(this.playbackInterval);      this.playbackInterval = null;    }        // Arrêt de l'animation frame    if (this.animationFrame) {      cancelAnimationFrame(this.animationFrame);      this.animationFrame = null;    }    // Mise à jour avec la frame courante    const frames = getCurrentFrames();    if (frames && frames[cursorIndex]) {      this.update(frames[cursorIndex]);    }  }}// Création d'une instance unique du visualiseurconst ayVisualizer = new AYWaveVisualizer();// Gestion du redimensionnementwindow.addEventListener('resize', () => {  ayVisualizer.resizeCanvases();  const frames = getCurrentFrames();  ayVisualizer.update(frames[cursorIndex]);});// Modification de renderAllconst originalRenderAll = window.renderAll;window.renderAll = function() {  if (typeof originalRenderAll === 'function') {    originalRenderAll.call(this);  }  const frames = getCurrentFrames();  ayVisualizer.update(frames[cursorIndex]);};// Modification de handleMouseconst originalHandleMouse = window.handleMouse;window.handleMouse = function(e, isRightClick) {  if (typeof originalHandleMouse === 'function') {    originalHandleMouse.call(this, e, isRightClick);  }  const frames = getCurrentFrames();  ayVisualizer.update(frames[cursorIndex]);};function enhancedStopAudio() {  // Arrêt de la source audio  if (playingSource) {    playingSource.stop();    playingSource = null;  }  // Nettoyage des intervalles de progression  if (progressUpdateInterval) {    clearInterval(progressUpdateInterval);    progressUpdateInterval = null;  }  // Réinitialisation de la barre de progression  document.getElementById("progressBar").style.width = "0%";  // Arrêt du visualiseur  if (ayVisualizer) {    ayVisualizer.stopVisualization();    const frames = getCurrentFrames();    if (frames && frames[cursorIndex]) {      ayVisualizer.update(frames[cursorIndex]);    }  }}// Remplacement complet de stopAudiowindow.stopAudio = enhancedStopAudio;// Mise à jour du gestionnaire d'événements du bouton stopdocument.getElementById("stopBtn").addEventListener("click", enhancedStopAudio);// S'assurer que la visualisation s'arrête quand le son se termine// Modification de la fonction playWav pour intégrer correctement la visualisationconst originalPlayWav = window.playWav;window.playWav = function(u8) {  stopAudio(); // Arrêter toute lecture en cours avant de commencer une nouvelle    const ctx = getAudioContext();  if (!ctx) return;    ctx.decodeAudioData(u8.buffer, (buffer) => {    playingSource = ctx.createBufferSource();    playingSource.buffer = buffer;    playingSource.connect(ctx.destination);        const startTime = ctx.currentTime;    const duration = buffer.duration;        playingSource.start(0);        // Démarrage de la visualisation    const frames = getCurrentFrames();    ayVisualizer.startVisualization(frames);        // Gestion de la barre de progression    const progressBar = document.getElementById("progressBar");    progressBar.style.width = "0%";        if (progressUpdateInterval) {      clearInterval(progressUpdateInterval);    }        progressUpdateInterval = setInterval(() => {      if (!ctx || ctx.state === "closed") {        stopAudio();        return;      }            const elapsed = ctx.currentTime - startTime;      const percent = Math.min(100, (elapsed / duration) * 100);            requestAnimationFrame(() => {        progressBar.style.width = percent + "%";      });            if (elapsed >= duration) {        stopAudio();      }    }, 16);        // Arrêt automatique à la fin    playingSource.onended = stopAudio;  });};//let isLiveMode = false;let currentLiveSource = null;function playLiveFrame(frame) {  if (!isLiveMode || !frame) return;    if (currentLiveSource) {    currentLiveSource.stop();    currentLiveSource = null;  }  if (!globalAudioContext || globalAudioContext.state === 'closed') {    const AudioCtx = window.AudioContext || window.webkitAudioContext;    globalAudioContext = new AudioCtx();  }  // Création d'un effet très court mais avec assez de frames pour le AY chip  const singleFrameEffect = [];  const numFramesNeeded = 50; // Le minimum nécessaire pour le AY chip    for (let i = 0; i < numFramesNeeded; i++) {    singleFrameEffect.push({      t: Boolean(frame.t),          // Force le type boolean      n: Boolean(frame.n),          // Force le type boolean      tone: Number(frame.tone) || 0, // Force le type number      noise: Number(frame.noise) || 0,      volume: Number(frame.volume) || 0    });  }    try {    const wave = createAYWaveFromFrames(singleFrameEffect);    if (!wave || !wave.buffer) {      console.error('Invalid wave data');      return;    }        globalAudioContext.decodeAudioData(wave.buffer, (buffer) => {      currentLiveSource = globalAudioContext.createBufferSource();      currentLiveSource.buffer = buffer;      currentLiveSource.connect(globalAudioContext.destination);      currentLiveSource.start(0);    }).catch(error => {      console.error('Error decoding audio:', error);    });  } catch(error) {    console.error('Error creating wave:', error);  }}// Ajouter le gestionnaire pour le bouton Live Modedocument.getElementById("liveModeBtn").addEventListener("click", () => {  isLiveMode = !isLiveMode;  const btn = document.getElementById("liveModeBtn");  if (isLiveMode) {    btn.classList.add('btn-primary');    notifyInfo('Sound Live Mode Enabled.')  } else {    btn.classList.remove('btn-primary');    if (currentLiveSource) {      currentLiveSource.stop();      currentLiveSource = null;    }    notifyInfo('Sound Live Mode Disabled.')  }});///// Fonction d'initialisation du système de toastfunction initToastSystem() {  // Trouver le conteneur de page  const pageContainer = document.querySelector('.page-container');    // Vérifier si le conteneur de toast existe déjà  let container = document.getElementById('toast-container');    // Si le conteneur n'existe pas, le créer  if (!container) {    container = document.createElement('div');    container.id = 'toast-container';    container.className = 'absolute top-0 left-0 right-0 flex flex-col items-center p-4 space-y-2 pointer-events-none';    container.style.top = '0px'; // Position en dessous du header    container.style.zIndex = '9999';    pageContainer.appendChild(container);  }    // Ajouter les styles   if (!document.getElementById('toast-styles')) {    const style = document.createElement('style');    style.id = 'toast-styles';    style.textContent = `   @keyframes slideIn {        from {           transform: translateY(-50px);           opacity: 0;         }        to {           transform: translateY(0);           opacity: 1;         }      }      @keyframes slideOut {        from {           transform: translateY(0);           opacity: 1;         }        to {           transform: translateY(-20px);           opacity: 0;         }      }            .toast {        background: rgba(45, 45, 45, 0.98);        backdrop-filter: blur(8px);        border: 1px solid #454545;        color: #fff;        padding: 12px 24px;        border-radius: 8px;        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);        margin-bottom: 8px;        animation: slideIn 0.4s ease forwards;        pointer-events: auto;        min-width: 300px;        text-align: center;      }            .toast.success {         border-left: 4px solid #10B981;        background: rgba(16, 185, 129, 0.1);      }            .toast.error {         border-left: 4px solid #EF4444;        background: rgba(239, 68, 68, 0.1);      }            .toast.info {         border-left: 4px solid #3B82F6;        background: rgba(59, 130, 246, 0.1);      }            .toast.removing {        animation: slideOut 0.4s ease forwards;      }    `;    document.head.appendChild(style);  }}function showToast(message, type = 'info', duration = 2500) { // Durée augmentée à 4 secondes  // S'assurer que le système est initialisé  initToastSystem();    const container = document.getElementById('toast-container');  const toast = document.createElement('div');  toast.className = `toast ${type}`;  toast.textContent = message;    container.appendChild(toast);    // Retirer les anciens toasts si trop nombreux  const toasts = container.getElementsByClassName('toast');  if (toasts.length > 3) {    container.removeChild(toasts[0]);  }    setTimeout(() => {    toast.classList.add('removing');    toast.addEventListener('animationend', () => {      if (container.contains(toast)) {        container.removeChild(toast);      }    });  }, duration);}// Remplacer les alert() existantsfunction notifySuccess(message) {  showToast(message, 'success');}function notifyError(message) {  showToast(message, 'error');}function notifyInfo(message) {  showToast(message, 'info');}// Initialiser le système au chargement de la pagedocument.addEventListener('DOMContentLoaded', initToastSystem);/// Gestion des .afxfunction decodeAFX(u8) {  const view = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);  let offset = 0;  const frames = [];    while (offset < u8.length) {    const byte = view.getUint8(offset++);    if (byte === 0xd0) {      const noiseByte = view.getUint8(offset++);      if (noiseByte >= 0x20) break; // Marqueur de fin    }        let tone = 0, noise = 0;    if (byte & (1 << 5)) {      tone = view.getUint16(offset, true) & 0xfff;      offset += 2;    }    if (byte & (1 << 6)) {      noise = view.getUint8(offset++);      noise &= 0x1f;    }        const frame = {      volume: byte & 0x0f,      t: !(byte & (1 << 4)),      n: !(byte & (1 << 7)),      tone: tone,      noise: noise    };    frames.push(frame);  }    // Compléter ou tronquer pour obtenir exactement NUM_FRAMES frames  while (frames.length < NUM_FRAMES) {    frames.push({ t: false, n: false, tone: 0, noise: 0, volume: 0 });  }  if (frames.length > NUM_FRAMES) {    frames.length = NUM_FRAMES;  }    return frames;}function loadAFXFile(u8) {  const frames = decodeAFX(u8);  if (frames) {   disableClearMode();   stopAudio();    bank.effects[bank.selected].frames = frames;    updateFxSelect();    renderAll();    notifySuccess("FX loaded successfully!");  } else {    notifyError("Error loading .afx file");  }}function saveAFXFile() { disableClearMode();   stopAudio();  const currentEffect = bank.effects[bank.selected];  const data = exportEffect(currentEffect);  downloadFile(data, currentEffect.name + ".afx", "application/octet-stream");  notifySuccess("FX saved as " + currentEffect.name + ".afx");}// 3. Ajouter les gestionnaires d'événementsdocument.getElementById('loadAfxBtn').addEventListener('click', () => {  document.getElementById('loadAfxFile').click();});document.getElementById('loadAfxFile').addEventListener('change', (e) => {  const file = e.target.files[0];  if (!file) return;    const reader = new FileReader();  reader.onload = function(ev) {    const u8 = new Uint8Array(ev.target.result);    loadAFXFile(u8);  };  reader.readAsArrayBuffer(file);});document.getElementById('saveAfxBtn').addEventListener('click', saveAFXFile);// 4. Ajouter l'event listener pour le toggle (à ajouter dans le script existant)document.getElementById('toggleHzBtn').addEventListener('click', () => {  playbackHz = playbackHz === 50 ? 60 : 50;    // Toggle la visibilité des icônes  document.getElementById('icon50Hz').classList.toggle('hidden', playbackHz === 60);  document.getElementById('icon60Hz').classList.toggle('hidden', playbackHz === 50);    // Mettre à jour le tooltip pour indiquer la prochaine action possible  const nextHz = playbackHz === 50 ? 60 : 50;  document.getElementById('toggleHzBtn').setAttribute('data-tooltip', `Toggle to ${nextHz}Hz`);    // Toggle la classe pour l'indication visuelle  document.getElementById('toggleHzBtn').classList.toggle('btn-primary', playbackHz === 60);    // Notification  notifyInfo(`Playback speed set to ${playbackHz}Hz`);    // Redémarrer la lecture si en cours  if (playingSource) {    const currentFrames = getCurrentFrames();    stopAudio();    playWav(createAYWaveFromFrames(currentFrames));  }});//// Welcome// Fonction principale pour créer et gérer la modal de bienvenuefunction createWelcomeModal() {  // Données des FX d'exemple  const sampleFXData = {    "FX 1": "175,194,0,175,0,0,175,97,0,175,0,0,174,35,1,174,0,0,174,194,0,174,0,0,173,97,0,173,0,0,173,35,1,173,0,0,172,194,0,172,0,0,172,97,0,172,0,0,171,35,1,171,0,0,171,194,0,171,0,0,170,97,0,170,0,0,170,35,1,170,0,0,169,194,0,169,0,0,169,97,0,169,0,0,168,35,1,168,0,0,168,194,0,168,0,0,167,97,0,167,0,0,167,35,1,167,0,0,166,194,0,166,0,0,166,97,0,166,0,0,165,35,1,165,0,0,165,194,0,165,0,0,164,97,0,164,0,0,164,35,1,164,0,0,163,194,0,163,0,0,163,97,0,163,0,0,162,35,1,162,0,0,162,194,0,162,0,0,130,129,129,129,129,208,32,97,114,99,97,110,111,105,100,50,95,49,0",      "FX 2": "125,77,5,7,125,0,0,9,93,2,91,19,91,0,91,14,89,0,89,14,89,29,87,14,87,29,87,13,85,29,85,13,85,30,208,32,100,114,117,105,100,95,49,0",    "FX 3": "237,128,1,6,237,0,2,0,173,128,1,173,0,2,127,0,0,20,95,0,31,16,16,16,95,18,95,0,95,16,95,0,94,14,94,0,94,12,94,0,93,10,93,0,93,12,93,0,92,10,92,0,91,6,91,0,27,27,27,24,24,24,24,24,23,23,23,23,22,22,22,22,22,21,21,21,21,21,208,32,118,97,109,112,105,114,101,107,105,108,108,101,114,95,50,0",    "FX 4": "233,85,0,6,234,51,0,0,171,17,0,169,85,0,170,51,0,169,85,0,170,51,0,171,17,0,169,85,0,170,51,0,171,17,0,170,85,0,171,51,0,172,17,0,171,85,0,172,51,0,173,17,0,172,85,0,173,51,0,174,17,0,172,85,0,173,51,0,174,17,0,173,85,0,174,51,0,175,17,0,174,85,0,175,51,0,175,17,0,175,85,0,175,51,0,175,17,0,175,85,0,175,51,0,175,17,0,174,85,0,174,51,0,174,17,0,173,85,0,172,51,0,172,17,0,172,85,0,172,51,0,172,17,0,171,85,0,171,51,0,171,17,0,171,85,0,171,51,0,171,17,0,171,85,0,170,51,0,208,32,118,97,109,112,105,114,101,107,105,108,108,101,114,95,54,0",    "FX 5": "94,26,94,30,80,0,94,26,94,30,94,26,94,30,80,0,94,28,80,0,94,26,80,0,94,24,94,20,94,16,94,12,94,8,94,6,94,2,94,0,175,51,0,175,19,0,175,119,0,175,151,0,175,51,0,175,19,0,174,119,0,174,151,0,174,51,0,174,19,0,174,119,0,174,151,0,174,51,0,174,19,0,172,119,0,172,151,0,172,51,0,172,46,0,172,41,0,172,36,0,172,31,0,172,26,0,172,21,0,172,16,0,175,51,0,175,45,0,175,39,0,175,33,0,175,27,0,175,21,0,175,15,0,175,9,0,174,119,0,174,151,0,174,183,0,174,215,0,174,247,0,174,23,1,174,55,1,174,87,1,174,51,0,174,45,0,174,39,0,174,33,0,174,27,0,174,21,0,174,15,0,174,9,0,173,119,0,173,151,0,173,183,0,173,215,0,173,247,0,173,23,1,173,55,1,173,87,1,172,51,0,172,45,0,172,39,0,172,33,0,172,27,0,172,21,0,172,15,0,172,119,0,172,151,0,172,183,0,172,215,0,171,51,0,171,45,0,171,39,0,171,33,0,170,27,0,170,21,0,170,15,0,170,9,0,208,32,118,97,109,112,105,114,101,107,105,108,108,101,114,95,49,49,0",    "FX 6": "237,238,1,30,237,0,0,0,173,204,1,173,0,0,172,238,1,172,0,0,171,255,1,171,0,0,170,153,1,170,0,0,169,136,1,169,0,0,168,119,1,168,0,0,167,102,1,167,0,0,166,119,1,166,0,0,165,136,1,165,0,0,164,153,1,164,0,0,208,32,112,101,110,103,117,105,110,97,100,118,101,110,116,117,114,101,95,51,0",    "FX 7": "236,67,0,30,237,88,0,0,174,70,0,173,74,0,173,79,0,172,85,0,172,92,0,176,4,9,176,0,0,144,144,144,169,68,0,171,71,0,170,75,0,170,80,0,169,86,0,169,93,0,176,4,9,176,0,0,144,166,69,0,168,72,0,167,76,0,167,81,0,166,87,0,166,94,0,208,32,112,101,110,103,117,105,110,97,100,118,101,110,116,117,114,101,95,55,0",    "FX 8": "236,150,1,27,236,31,1,0,172,106,1,172,255,0,172,66,1,172,228,0,172,31,1,172,203,0,172,255,0,172,181,0,172,228,0,172,161,0,172,203,0,172,143,0,172,181,0,172,127,0,208,32,122,97,110,97,99,95,49,0",    "FX 9": "239,40,0,27,239,170,0,0,175,40,0,175,170,0,174,40,0,174,170,0,174,40,0,174,170,0,173,40,0,173,170,0,173,40,0,173,170,0,172,40,0,172,170,0,172,40,0,172,170,0,171,40,0,171,170,0,171,40,0,171,170,0,170,40,0,170,170,0,170,40,0,170,170,0,169,40,0,169,170,0,169,40,0,169,170,0,168,40,0,168,170,0,168,40,0,168,170,0,167,40,0,167,170,0,167,40,0,167,170,0,166,40,0,166,170,0,166,40,0,166,170,0,165,40,0,165,170,0,165,40,0,165,170,0,164,40,0,164,170,0,164,40,0,164,170,0,208,32,122,97,110,97,99,95,50,0",    "FX 10": "97,147,5,14,98,45,0,0,35,147,5,36,45,0,37,147,5,38,45,0,39,147,5,40,45,0,41,147,5,42,45,0,107,147,5,13,108,45,0,0,45,147,5,45,45,0,45,147,5,45,45,0,45,147,5,45,45,0,45,147,5,45,45,0,109,147,5,12,108,45,0,0,44,147,5,44,45,0,44,147,5,44,45,0,44,147,5,44,45,0,44,147,5,44,45,0,107,147,5,11,107,45,0,0,43,147,5,43,45,0,43,147,5,43,45,0,43,147,5,43,45,0,43,147,5,42,45,0,106,147,5,10,106,45,0,0,42,147,5,42,45,0,42,147,5,42,45,0,42,147,5,42,45,0,41,147,5,41,45,0,105,147,5,9,105,45,0,0,41,147,5,41,45,0,41,147,5,41,45,0,41,147,5,40,45,0,40,147,5,40,45,0,104,147,5,8,104,45,0,0,40,147,5,40,45,0,40,147,5,40,45,0,39,147,5,39,45,0,39,147,5,39,45,0,103,147,5,7,103,45,0,0,208,32,99,121,98,101,114,110,111,105,100,95,50,0",    "FX 11": "171,35,1,172,37,1,172,39,1,172,41,1,173,43,1,175,41,1,171,133,1,172,135,1,172,137,1,172,139,1,173,141,1,175,139,1,171,71,1,172,73,1,172,75,1,172,77,1,173,79,1,175,77,1,171,181,1,172,183,1,172,185,1,172,187,1,173,189,1,175,187,1,171,133,1,172,135,1,172,137,1,172,139,1,173,141,1,175,139,1,171,234,1,172,236,1,172,238,1,172,240,1,173,242,1,175,240,1,171,71,2,172,73,2,172,75,2,172,77,2,173,79,2,175,77,2,171,142,4,172,144,4,172,146,4,172,148,4,173,150,4,175,148,4,171,142,4,172,144,4,172,146,4,172,148,4,173,150,4,175,148,4,174,146,4,174,0,0,141,141,141,140,140,140,139,139,138,138,138,137,137,137,136,136,135,135,135,134,134,134,133,133,132,132,132,131,131,131,130,130,129,129,129,208,32,97,114,99,97,110,111,105,100,50,95,52,0"  };  // Créer la modal  const modal = document.createElement('div');  modal.className = 'welcome-modal';  // HTML de la modal  modal.innerHTML = `    <div class="modal-content-welcome">      <div class="modal-header flex items-center gap-4 mb-6">        <div class="p-3 rounded-lg bg-indigo-600/30 border border-indigo-500/30">          <svg class="w-8 h-8 text-indigo-300" viewBox="0 0 24 24" fill="none">            <path d="M9 17H6.5L2 12 6.5 7H9M15 17H17.5L22 12 17.5 7H15"                   stroke="currentColor" stroke-width="2"                   stroke-linecap="round" stroke-linejoin="round"/>          </svg>        </div>        <div>          <h2 class="text-2xl font-semibold text-white">Welcome to Fusion FX! Editor</h2>          <p class="text-indigo-200">Create amazing sound effects for your MSX games</p>        </div>        <button class="close-modal absolute top-4 right-4 text-gray-400 hover:text-white">          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">            <path d="M18 6L6 18M6 6l12 12" stroke-width="2" stroke-linecap="round"/>          </svg>        </button>      </div>      <div class="modal-body text-gray-200 space-y-4">        <p>Would you like to import sample sound effects to get started?           These examples showcase various effects you can create:</p>                <ul class="feature-list grid grid-cols-2 gap-3 py-4">          <li><span class="feature-dot"></span>Arcade style sounds</li>          <li><span class="feature-dot"></span>Weapon effects</li>          <li><span class="feature-dot"></span>Environmental effects</li>          <li><span class="feature-dot"></span>Character actions</li>        </ul>      </div>      <div class="modal-footer flex justify-end gap-4 mt-8">        <button class="modal-btn secondary">Maybe Later</button>        <button class="modal-btn primary">Import Examples</button>      </div>    </div>  `;// Fonctions de gestion de la modal  function showModal() {    document.body.appendChild(modal);    requestAnimationFrame(() => {      modal.classList.add('active');    });  }  function closeModal() {    modal.classList.add('closing');    modal.classList.remove('active');    setTimeout(() => {      modal.remove();    }, 300);  }  // Import des FX d'exemple  async function importSampleFX() {    try {      const fxList = Object.values(sampleFXData);            for (let i = 0; i < fxList.length; i++) {        const fxData = fxList[i];                // Mettre les données dans le textarea        const fxImportData = document.querySelector('#fxImportData');        fxImportData.value = fxData;                // Importer le FX        document.querySelector('#pasteFxBtn').click();                // Créer un nouveau FX sauf pour le dernier        if (i < fxList.length - 1) {          document.querySelector('#newFxBtn').click();          // Attendre un peu entre chaque import          await new Promise(resolve => setTimeout(resolve, 100));        }      }      // S'assurer que le premier FX est sélectionné    const fxSelect = document.querySelector('#fxSelect');    fxSelect.selectedIndex = 0;    fxSelect.dispatchEvent(new Event('change')); // Déclencher l'événement change    // Vider le champ d'import FX    document.querySelector('#fxImportData').value = '';      closeModal();      notifySuccess('Sample FX bank imported successfully!');    } catch (error) {      console.error('Error importing FX:', error);      notifyError('Failed to import sample FX bank');    }  }  // Gestionnaires d'événements  const closeButtons = modal.querySelectorAll('.close-modal, .modal-btn.secondary');  closeButtons.forEach(btn => {    btn.addEventListener('click', closeModal);  });  modal.querySelector('.modal-btn.primary').addEventListener('click', importSampleFX);  // Fermer en cliquant en dehors de la modal  modal.addEventListener('click', (e) => {    if (e.target === modal) {      closeModal();    }  });  // Empêcher la propagation des clics depuis le contenu  modal.querySelector('.modal-content-welcome').addEventListener('click', (e) => {    e.stopPropagation();  });  // Afficher la modal  showModal();}// Initialiser la modal au chargement de la pagedocument.addEventListener('DOMContentLoaded', () => {   // Créer la modal  createWelcomeModal();});/// WAV/// WAV Import & Processing Code// Paramètres ajustables pour la conversion WAVlet wavConversionParams = {  // Volume  VOLUME_SCALE: 2.6,           // Facteur d'amplification du volume (augmenter pour plus de volume)  VOLUME_SMOOTHING: 0.7,       // Facteur de lissage du volume (0-1, plus haut = plus lisse)  VOLUME_CURVE: 0.7,           // Exposant de la courbe de volume (< 1 = compression, > 1 = expansion)  // Détection de pitch  PITCH_THRESHOLD: 0.1,        // Seuil de détection du pitch (0.1-0.3, plus bas = plus sensible)  MIN_TONE: 1,                 // Valeur minimale de tone  MAX_TONE: 4095,             // Valeur maximale de tone  // Détection de bruit  NOISE_SENSITIVITY: 10,       // Sensibilité à la détection du bruit (augmenter pour plus de bruit)  NOISE_THRESHOLD: 5,          // Seuil minimum pour activer le noise (0-31)  HIGH_FREQ_THRESHOLD: 4,      // Diviseur pour la détection des hautes fréquences  // Paramètres généraux  FRAME_RATE: 50,             // Taux de frames par seconde  FFT_SIZE: 2048,             // Taille de la FFT pour l'analyse spectrale  WINDOW_SIZE: 512            // Taille de la fenêtre d'analyse pour le volume};// Fonction pour détecter le bruit avec sensibilité ajustablefunction detectNoiseWithSensitivity(samples, sampleRate, sensitivity) {  const fftSize = wavConversionParams.FFT_SIZE;  const fft = new Float32Array(fftSize);  const hannWindow = new Float32Array(fftSize);    // Application de la fenêtre de Hann  for (let i = 0; i < fftSize; i++) {    hannWindow[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));  }  for (let i = 0; i < Math.min(fftSize, samples.length); i++) {    fft[i] = samples[i] * hannWindow[i];  }  let totalEnergy = 0;  let highFreqEnergy = 0;  for (let i = 0; i < fftSize; i++) {    const energy = fft[i] * fft[i];    totalEnergy += energy;        if (i > fftSize / wavConversionParams.HIGH_FREQ_THRESHOLD) {      highFreqEnergy += energy;    }  }  const noiseRatio = totalEnergy > 0 ? highFreqEnergy / totalEnergy : 0;  return Math.min(31, Math.round(noiseRatio * sensitivity));}// Fonction pour détecter le volume avec lissagefunction detectVolume(samples, prevVolume, volumeScale) {  if (!samples || samples.length === 0) return 0;  const windowSize = Math.min(samples.length, wavConversionParams.WINDOW_SIZE);  let maxRms = 0;  for (let i = 0; i <= samples.length - windowSize; i += windowSize / 2) {    let sumSq = 0;    for (let j = 0; j < windowSize; j++) {      if (i + j < samples.length) {        sumSq += samples[i + j] * samples[i + j];      }    }    const rms = Math.sqrt(sumSq / windowSize);    maxRms = Math.max(maxRms, rms);  }  const volume = Math.min(15, Math.round(    Math.pow(maxRms * volumeScale, wavConversionParams.VOLUME_CURVE) * 15  ));  return Math.round(    volume * wavConversionParams.VOLUME_SMOOTHING +     prevVolume * (1 - wavConversionParams.VOLUME_SMOOTHING)  );}// Fonction pour détecter le pitch avec seuil ajustablefunction detectPitchWithThreshold(buffer, sampleRate, threshold) {  const bufferSize = buffer.length;  const halfBufferSize = Math.floor(bufferSize / 2);  const yinBuffer = new Float32Array(halfBufferSize);  for (let tau = 0; tau < halfBufferSize; tau++) {    let sum = 0;    for (let i = 0; i < halfBufferSize; i++) {      const delta = buffer[i] - buffer[i + tau];      sum += delta * delta;    }    yinBuffer[tau] = sum;  }  let runningSum = 0;  yinBuffer[0] = 1;  for (let tau = 1; tau < halfBufferSize; tau++) {    runningSum += yinBuffer[tau];    yinBuffer[tau] *= tau / runningSum;  }  let tauEstimate = -1;  let minValue = 1;  for (let tau = 2; tau < halfBufferSize; tau++) {    if (yinBuffer[tau] < threshold && yinBuffer[tau] < minValue) {      minValue = yinBuffer[tau];      tauEstimate = tau;    }  }  if (tauEstimate === -1) return 0;  let betterTau = tauEstimate;  if (tauEstimate > 0 && tauEstimate < halfBufferSize - 1) {    const s0 = yinBuffer[tauEstimate - 1];    const s1 = yinBuffer[tauEstimate];    const s2 = yinBuffer[tauEstimate + 1];    const adjustment = (s2 - s0) / (2 * (2 * s1 - s2 - s0));    betterTau = tauEstimate + adjustment;  }  return sampleRate / betterTau;}// Fonction principale de conversion WAV vers FXasync function convertWavToFX(arrayBuffer) {  try {    const AudioCtx = window.AudioContext || window.webkitAudioContext;    if (!AudioCtx) {      throw new Error("AudioContext not supported");    }    const ctx = new AudioCtx();    const audioBuffer = await ctx.decodeAudioData(arrayBuffer);    const sampleRate = audioBuffer.sampleRate;    const channelData = audioBuffer.getChannelData(0);        // Normalisation du signal    let maxAmplitude = 0;    for (let i = 0; i < channelData.length; i++) {      maxAmplitude = Math.max(maxAmplitude, Math.abs(channelData[i]));    }        const normalizedData = new Float32Array(channelData.length);    const normalizationFactor = maxAmplitude > 0 ? 1 / maxAmplitude : 1;    for (let i = 0; i < channelData.length; i++) {      normalizedData[i] = channelData[i] * normalizationFactor;    }    const frameDuration = 1 / wavConversionParams.FRAME_RATE;    const samplesPerFrame = Math.floor(sampleRate * frameDuration);    const totalFrames = Math.floor(normalizedData.length / samplesPerFrame);    const NUM_FRAMES = 255;    const fxFrames = [];    let prevTone = 0;    let prevVolume = 0;    for (let f = 0; f < NUM_FRAMES; f++) {      let frameSamples;      if (f < totalFrames) {        frameSamples = normalizedData.slice(f * samplesPerFrame, (f + 1) * samplesPerFrame);      } else {        frameSamples = new Float32Array(samplesPerFrame);      }      const volume = detectVolume(frameSamples, prevVolume, wavConversionParams.VOLUME_SCALE);      prevVolume = volume;      const frequency = detectPitchWithThreshold(frameSamples, sampleRate, wavConversionParams.PITCH_THRESHOLD);      let tone;            if (frequency && frequency > 0) {        tone = Math.floor(1773400 / (16 * frequency));        tone = Math.max(wavConversionParams.MIN_TONE, Math.min(wavConversionParams.MAX_TONE, tone));        prevTone = tone;      } else {        tone = prevTone;      }      const noise = detectNoiseWithSensitivity(frameSamples, sampleRate, wavConversionParams.NOISE_SENSITIVITY);      const hasSignificantNoise = noise > wavConversionParams.NOISE_THRESHOLD;      const frame = {        volume,        tone,        noise,        t: tone > 0 && volume > 0,        n: hasSignificantNoise && volume > 0      };      fxFrames.push(frame);    }    ctx.close();    return {       name: "Converted WAV",      frames: fxFrames     };  } catch (error) {    throw new Error(`WAV conversion failed: ${error.message}`);  }}// Gestionnaires d'événements pour l'interfacedocument.addEventListener('DOMContentLoaded', () => {  // Configuration des sliders  const sliderConfig = {    volumeScaleSlider: {      valueId: 'volumeScaleValue',      paramKey: 'VOLUME_SCALE',      format: value => Number(value).toFixed(1)    },    pitchThresholdSlider: {      valueId: 'pitchThresholdValue',      paramKey: 'PITCH_THRESHOLD',      format: value => Number(value).toFixed(2)    },    noiseSensitivitySlider: {      valueId: 'noiseSensitivityValue',      paramKey: 'NOISE_SENSITIVITY',      format: value => Number(value).toFixed(0)    }  };  // Fonction pour mettre à jour un slider et sa valeur function updateSlider(sliderId, value) {    const config = sliderConfig[sliderId];    const valueDisplay = document.getElementById(config.valueId);    const formattedValue = config.format(value);    valueDisplay.textContent = formattedValue;    wavConversionParams[config.paramKey] = Number(value);  }  // Initialisation des sliders Object.entries(sliderConfig).forEach(([sliderId, config]) => {    const slider = document.getElementById(sliderId);    if (slider) {      updateSlider(sliderId, slider.value);      slider.addEventListener('input', (e) => {        updateSlider(sliderId, e.target.value);      });    }  });  // Gestion du panneau WAV Controls  const wavControlsToggle = document.getElementById('wavControlsToggle');  const wavControlsContainer = wavControlsToggle.closest('.piano-container');  const wavToggleIcon = wavControlsToggle.querySelector('.toggle-icon');  function updateWavControlsCollapsed() {    if (wavControlsContainer.classList.contains('collapsed')) {      wavControlsContainer.style.height = wavControlsToggle.offsetHeight + 'px';      wavToggleIcon.textContent = '▶';    } else {      wavControlsContainer.style.height = 'auto';      wavToggleIcon.textContent = '▼';    }  }  wavControlsToggle.addEventListener('click', () => {    wavControlsContainer.classList.toggle('collapsed');    updateWavControlsCollapsed();  });  updateWavControlsCollapsed();  // Gestionnaires pour l'import WAV      document.getElementById('importWavBtn').addEventListener('click', () => {        disableClearMode();        stopAudio();        document.getElementById('importWavFile').click();      });     document.getElementById('importWavFile').addEventListener('change', async (e) => {      const file = e.target.files[0];      if (!file) return;      try {        notifyInfo('Converting WAV to FX... Please wait.');        const reader = new FileReader();                reader.onload = async (ev) => {          try {            const fx = await convertWavToFX(ev.target.result);            stopAudio(); // Arrêter encore une fois par sécurité                        fx.name = file.name.replace(/\.[^/.]+$/, "");                        bank.effects[bank.selected] = fx;            updateFxSelect();            renderAll();            notifySuccess('WAV successfully converted to FX!');          } catch (error) {            console.error('Conversion error:', error);            notifyError('Failed to convert WAV: ' + error.message);          }        };        reader.onerror = () => {          notifyError('Error reading WAV file');        };        reader.readAsArrayBuffer(file);      } catch (error) {        console.error('Import error:', error);        notifyError('Failed to import WAV file');      }            e.target.value = '';    });});/// Zoom// Gestion du zoom// Variables pour contrôler le zoomlet zoomLevel = 0; // 0=4px, 1=5px, 2=6px, 3=7px, 4=8pxconst zoomLevels = [4, 5, 6, 7, 8]; // Pixels par frame pour chaque niveau// Créer le bouton de zoom négatifconst zoomOutBtn = document.createElement('button');zoomOutBtn.id = 'zoomOutBtn';zoomOutBtn.className = 'btn btn-icon';zoomOutBtn.setAttribute('data-tooltip', 'Zoom Out Editor area');zoomOutBtn.innerHTML = `  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">        <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>        <line x1="8" y1="21" x2="16" y2="21"/>        <line x1="12" y1="17" x2="12" y2="21"/>        <line x1="8" y1="10" x2="16" y2="10"/>      </svg>`;zoomOutBtn.style.display = 'none'; // Caché par défaut// Renommer l'ID du bouton zoom actuel pour plus de clartéconst zoomBtn = document.getElementById('zoomBtn');zoomBtn.id = 'zoomInBtn';// Insérer le bouton de zoom négatif APRÈS le bouton de zoomzoomBtn.parentNode.insertBefore(zoomOutBtn, zoomBtn.nextSibling);// Fonction pour appliquer le zoomfunction applyZoom(level) {  // Limiter le niveau entre 0 et 4  level = Math.max(0, Math.min(4, level));  zoomLevel = level;    // Récupérer la valeur en pixels pour ce niveau  FRAME_WIDTH = zoomLevels[level];  CANVAS_WIDTH = FRAME_WIDTH * NUM_FRAMES;    // Mettre à jour la largeur du canvas  const canvas = document.getElementById('editorCanvas');  canvas.width = CANVAS_WIDTH + LABEL_WIDTH;    // Afficher ou masquer le bouton de zoom négatif  zoomOutBtn.style.display = level > 0 ? 'inline-flex' : 'none';    // Mettre à jour les tooltips et icônes des boutons  const zoomInText = level < 4 ? `Zoom In Editor area (${zoomLevels[level+1]}px/frame)` : 'Maximum zoom reached';  zoomBtn.setAttribute('data-tooltip', zoomInText);    // Désactiver le bouton de zoom+ si on est au maximum  zoomBtn.disabled = level >= 4;  zoomBtn.classList.toggle('opacity-50', level >= 4);    // Mettre à jour les éléments visuels  renderAll();  updateCursorAnchor();    // Notification  notifyInfo(`Editor view set to ${FRAME_WIDTH} px per frame`);}// Événement pour le bouton de zoom positifzoomBtn.addEventListener('click', () => {  if (zoomLevel < 4) {    applyZoom(zoomLevel + 1);  }});// Événement pour le bouton de zoom négatifzoomOutBtn.addEventListener('click', () => {  if (zoomLevel > 0) {    applyZoom(zoomLevel - 1);  }});// Initialiser au premier niveau de zoom (4px)function initZoom() {  applyZoom(0);}// Initialiser le zoom au chargement de la pagedocument.addEventListener('DOMContentLoaded', initZoom);// Remplacer le gestionnaire d'événements existantconst oldZoomBtnClickHandler = zoomBtn.onclick;zoomBtn.onclick = null; // Supprimer l'ancien gestionnaire// Bulk Edit// Ajout du flag X dans la section Flagsconst flagsSection = document.querySelector('.grid-cols-6 div:nth-child(5) .flex.gap-2');const xFlagLabel = document.createElement('label');xFlagLabel.className = 'inline-flex items-center ml-2';xFlagLabel.innerHTML = `  <input type="checkbox" id="xFlag" class="form-checkbox">  <span class="ml-1" title="When checked, + and - buttons will only modify frames with volume or tone > 0">X</span>`;flagsSection.appendChild(xFlagLabel);// Création des contrôles de sélectionfunction createSelectionControls() {  const container = document.createElement('div');  container.id = 'selectionControlsContainer';  container.style.cssText = `    position: absolute;    top: 0;    left: 0;    right: 0;    bottom: 0;    pointer-events: none;    z-index: 10;  `;  // Calcul précis des positions pour chaque ligne  const toneY = getRowY(2); // Position de la ligne TONE  const volY = getRowY(4);  // Position de la ligne VOL    // Configuration des boutons avec leurs positions ajustées  const controls = [    {      param: 'tone',      delta: 100,      label: '+',      top: toneY + 20, // En haut de la zone TONE      left: LABEL_WIDTH -15    },    {      param: 'tone',      delta: -100,      label: '-',      top: toneY + ROWS[2].height -5, // En bas de la zone TONE      left: LABEL_WIDTH  -15    },    {      param: 'volume',      delta: 1,      label: '+',      top: volY + 20, // En haut de la zone VOL      left: LABEL_WIDTH  -15    },    {      param: 'volume',      delta: -1,      label: '-',      top: volY + ROWS[4].height -5, // En bas de la zone VOL      left: LABEL_WIDTH  -15    }  ];  controls.forEach(ctrl => {    const button = document.createElement('button');    button.textContent = ctrl.label;    button.className = 'selection-control-btn';    button.style.cssText = `      position: absolute;      left: ${ctrl.left}px;      top: ${ctrl.top}px;      width: 20px;      height: 20px;      background: #4a5568;      color: white;      border: 0px;      border-radius: 50%;      cursor: pointer;      font-weight: bold;      pointer-events: auto;      display: flex;      align-items: center;      justify-content: center;      box-shadow: 0 2px 4px rgba(0,0,0,0.2);      transition: all 0.2s;      z-index: 20;    `;    button.addEventListener('mouseover', () => {      button.style.background = '#718096';    });    button.addEventListener('mouseout', () => {      button.style.background = '#4a5568';    });    button.addEventListener('click', () => {      if (!isSelectionMode || selectionStart === null || selectionEnd === null) return;            const frames = getCurrentFrames();      const start = Math.min(selectionStart, selectionEnd);      const end = Math.max(selectionStart, selectionEnd);      const xFlagChecked = document.getElementById('xFlag').checked;      // Mise à jour des valeurs et de l'interface      for (let i = start; i <= end; i++) {        // Vérifier si la frame doit être modifiée selon le flag X et le paramètre        let shouldModify = !xFlagChecked; // Par défaut, on modifie si X n'est pas coché                if (xFlagChecked) {          if (ctrl.param === 'tone') {            shouldModify = frames[i].tone > 0;          } else if (ctrl.param === 'volume') {            shouldModify = frames[i].volume > 0;          }        }                if (!shouldModify) continue;        if (ctrl.param === 'tone') {          frames[i].tone = Math.min(4095, Math.max(0, frames[i].tone + ctrl.delta));          // Mise à jour de l'input tone si on est sur la frame courante          if (i === cursorIndex) {            document.getElementById('toneInput').value = frames[i].tone;          }        } else if (ctrl.param === 'volume') {          frames[i].volume = Math.min(15, Math.max(0, frames[i].volume + ctrl.delta));          // Mise à jour de l'input volume si on est sur la frame courante          if (i === cursorIndex) {            document.getElementById('volumeInput').value = frames[i].volume;          }        }      }            renderAll();    });    container.appendChild(button);  });  return container;}// Modification de la fonction toggleSelectionMode existanteconst originalToggleSelectionMode = toggleSelectionMode;toggleSelectionMode = function(enable) {  originalToggleSelectionMode(enable);    let container = document.getElementById('selectionControlsContainer');  if (enable) {    if (!container) {      container = createSelectionControls();      document.querySelector('.canvas-container').appendChild(container);    }    container.style.display = 'block';    // Afficher le flag X    document.getElementById('xFlag').parentElement.style.display = 'inline-flex';  } else {    if (container) {      container.style.display = 'none';    }    // Cacher le flag X    document.getElementById('xFlag').parentElement.style.display = 'none';  }};// Style pour les boutonsconst style = document.createElement('style');style.textContent = `  .selection-control-btn:active {    transform: translateY(1px);    box-shadow: 0 1px 2px rgba(0,0,0,0.2);  }    .selection-control-btn:focus {    outline: none;    box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.5);  }  #xFlag {    cursor: pointer;  } #xFlag + span,  #tInput + span,  #nInput + span {    cursor: help;  }`;document.head.appendChild(style);// Par défaut, cacher le flag X (il sera affiché en mode sélection)document.getElementById('xFlag').parentElement.style.display = 'none';/// Interpolations// Basic interpolation functionsfunction linearInterpolation(start, end, t) {  return start + (end - start) * t;}function parabolicInterpolation(start, end, t) {  return start + (end - start) * (t * t);}function inverseParabolicInterpolation(start, end, t) {  return start + (end - start) * (1 - (1 - t) * (1 - t));}function flatNormalization(start, end) {  return Math.round((start + end) / 2);}// Effect generation for empty zonesfunction generateEmptyZoneEffect(type, t, maxValue) {  switch(type) {    case 'up':      return Math.round(maxValue * t);          case 'down':      return Math.round(maxValue * (1 - t));          case 'parabolic': {      // y = -4(x-0.5)² + 1      // Courbe en cloche : min -> max -> min      const x = t - 0.5;      return Math.round(maxValue * (-4 * x * x + 1));    }        case 'inverseParabolic': {      // y = 4(x-0.5)² + 0      // Courbe en U : max -> min -> max      const x = t - 0.5;      return Math.round(maxValue * (4 * x * x));    }        case 'flat':      return Math.round(maxValue / 2);          default:      return 0;  }}// Main interpolation functionfunction applyInterpolation(frames, start, end, paramName, interpFunc) {  const length = end - start;  if (length <= 0) return;    // Check if zone is empty  let isEmpty = true;  for (let i = start; i <= end; i++) {    if (frames[i][paramName] !== 0) {      isEmpty = false;      break;    }  }    const maxValue = paramName === 'volume' ? 15 : 4095;    // Determine effect type for empty zone  let emptyZoneType = 'up';  if (interpFunc.toString().includes('end, start')) {    emptyZoneType = 'down';  } else if (interpFunc === parabolicInterpolation) {    emptyZoneType = 'parabolic';  } else if (interpFunc === inverseParabolicInterpolation) {    emptyZoneType = 'inverseParabolic';  } else if (interpFunc.toString().includes('flatNormalization')) {    emptyZoneType = 'flat';  }    // Apply interpolation  for (let i = start; i <= end; i++) {    const t = (i - start) / length;    let value;        if (isEmpty) {      value = generateEmptyZoneEffect(emptyZoneType, t, maxValue);    } else {      const startValue = frames[start][paramName];      const endValue = frames[end][paramName];      value = Math.round(interpFunc(startValue, endValue, t));    }        frames[i][paramName] = Math.max(0, Math.min(maxValue, value));  }}// À ajouter après avoir supprimé le code mentionnédocument.addEventListener('DOMContentLoaded', () => {  // Volume Up  document.querySelector('.interpolation-group:nth-child(1) .interpolation-btn:nth-child(1)').addEventListener('click', () => {    applyInterpolationWithCheck('volume', linearInterpolation, 'Linear Volume Up');  });    // Volume Down  document.querySelector('.interpolation-group:nth-child(1) .interpolation-btn:nth-child(2)').addEventListener('click', () => {    applyInterpolationWithCheck('volume', (start, end, t) => start - (start - end) * t, 'Linear Volume Down');  });    // Parabolic Volume  document.querySelector('.interpolation-group:nth-child(1) .interpolation-btn:nth-child(3)').addEventListener('click', () => {    applyInterpolationWithCheck('volume', parabolicInterpolation, 'Parabolic Volume');  });    // Inverse Parabolic Volume  document.querySelector('.interpolation-group:nth-child(1) .interpolation-btn:nth-child(4)').addEventListener('click', () => {    applyInterpolationWithCheck('volume', inverseParabolicInterpolation, 'Inverse Parabolic Volume');  });    // Flat Normalize Volume  document.querySelector('.interpolation-group:nth-child(1) .interpolation-btn:nth-child(5)').addEventListener('click', () => {    applyInterpolationWithCheck('volume', (start, end, t) => flatNormalization(start, end), 'Flat Normalize Volume');  });    // Tone Up  document.querySelector('.interpolation-group:nth-child(2) .interpolation-btn:nth-child(1)').addEventListener('click', () => {    applyInterpolationWithCheck('tone', linearInterpolation, 'Linear Tone Up');  });    // Tone Down  document.querySelector('.interpolation-group:nth-child(2) .interpolation-btn:nth-child(2)').addEventListener('click', () => {    applyInterpolationWithCheck('tone', (start, end, t) => start - (start - end) * t, 'Linear Tone Down');  });    // Parabolic Tone  document.querySelector('.interpolation-group:nth-child(2) .interpolation-btn:nth-child(3)').addEventListener('click', () => {    applyInterpolationWithCheck('tone', parabolicInterpolation, 'Parabolic Tone');  });    // Inverse Parabolic Tone  document.querySelector('.interpolation-group:nth-child(2) .interpolation-btn:nth-child(4)').addEventListener('click', () => {    applyInterpolationWithCheck('tone', inverseParabolicInterpolation, 'Inverse Parabolic Tone');  });    // Flat Normalize Tone  document.querySelector('.interpolation-group:nth-child(2) .interpolation-btn:nth-child(5)').addEventListener('click', () => {    applyInterpolationWithCheck('tone', (start, end, t) => flatNormalization(start, end), 'Flat Normalize Tone');  });    // Fonction helper pour vérifier la sélection avant d'appliquer l'interpolation  function applyInterpolationWithCheck(paramName, interpFunc, description) {    if (!isSelectionMode || selectionStart === null || selectionEnd === null) {      notifyError('Please select a range of frames first');      return;    }        try {      const frames = getCurrentFrames();      const start = Math.min(selectionStart, selectionEnd);      const end = Math.max(selectionStart, selectionEnd);            applyInterpolation(frames, start, end, paramName, interpFunc);      renderAll();            notifySuccess(`Applied ${description}`);    } catch (error) {      console.error('Interpolation error:', error);      notifyError('Failed to apply interpolation');    }  }}); /// Clear Functions// Gestionnaire d'événements pour le bouton Clear Modedocument.getElementById("clearModeBtn").addEventListener("click", () => {  isClearMode = !isClearMode;    // Si on active le mode Clear et qu'on a déjà une sélection  if (isClearMode && isSelectionMode && selectionStart !== null && selectionEnd !== null) {    // On garde la sélection en mémoire pour l'effacement    const start = Math.min(selectionStart, selectionEnd);    const end = Math.max(selectionStart, selectionEnd);    clearRangeStart = start;    clearRangeEnd = end;  }    if (isClearMode) {    document.getElementById("clearModeBtn").classList.add('btn-primary');    canvas.classList.add('clear-mode');    notifyInfo('Clear Mode Enabled. Click on a track to clear it.');  } else {    document.getElementById("clearModeBtn").classList.remove('btn-primary');    canvas.classList.remove('clear-mode');    notifyInfo('Clear Mode Disabled.');  }});/// Coffee// Amélioration de la gestion du modal Coffeefunction initCoffeeModal() {  const coffeeBtn = document.getElementById('coffeeBtn');  const coffeeModal = document.getElementById('coffeeModal');  const closeBtn = coffeeModal.querySelector('.close-modal');  const paypalBtn = document.getElementById('paypalBtn');  const amountInput = document.getElementById('coffeeAmount');  function showModal() {    coffeeModal.classList.remove('closing');    coffeeModal.style.display = 'flex';    // Attendre le prochain frame pour l'animation    requestAnimationFrame(() => {      coffeeModal.classList.add('active');    });        // Mettre à jour le temps d'utilisation    const usageTimeSpan = coffeeModal.querySelector('.usage-time');    if (usageTimeSpan && UsageTracker) {      usageTimeSpan.textContent = UsageTracker.getUsageTime();    }  }  function closeModal() {    coffeeModal.classList.add('closing');    coffeeModal.classList.remove('active');        setTimeout(() => {      coffeeModal.style.display = 'none';      coffeeModal.classList.remove('closing');    }, 300);  }  // Event listeners optimisés  coffeeBtn.addEventListener('click', showModal);  closeBtn.addEventListener('click', closeModal);    paypalBtn.addEventListener('click', () => {    const amount = parseFloat(amountInput.value) || 3;    const paypalUrl = `https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&business=eric@ebsoft.fr&currency_code=EUR&amount=${amount}&item_name=Coffee for Fusion FX! Editor`;    window.open(paypalUrl, '_blank');    closeModal();  });  // Fermeture en cliquant en dehors  coffeeModal.addEventListener('click', (e) => {    if (e.target === coffeeModal) {      closeModal();    }  });  // Empêcher la propagation depuis le contenu  coffeeModal.querySelector('.modal-content-welcome').addEventListener('click', (e) => {    e.stopPropagation();  });  // Validation de l'input montant  amountInput.addEventListener('input', (e) => {    let value = parseFloat(e.target.value);    if (isNaN(value) || value < 1) e.target.value = 1;    if (value > 100) e.target.value = 100;  });}// Initialisation au chargement de la pagedocument.addEventListener('DOMContentLoaded', initCoffeeModal);// Gestionnaire du temps d'utilisation// Initialiser immédiatement le UsageTrackerconst UsageTracker = {  startTime: null,  totalTime: 0,  storageKey: 'fusionAYFX_usageTime',  saveInterval: null,    init() {    // Récupérer le temps total depuis le localStorage    const savedTime = localStorage.getItem(this.storageKey);    this.totalTime = savedTime ? parseInt(savedTime, 10) : 0;        // Démarrer le compteur    this.startTime = Date.now();        // Sauvegarder toutes les 30 secondes    this.saveInterval = setInterval(() => this.saveTime(), 30000);        // Sauvegarder avant de quitter la page    window.addEventListener('beforeunload', () => {      this.saveTime();      if (this.saveInterval) {        clearInterval(this.saveInterval);      }    });        // Mettre à jour l'affichage quand la modale est ouverte    const coffeeBtn = document.getElementById('coffeeBtn');    if (coffeeBtn) {      coffeeBtn.addEventListener('click', () => {        const usageTimeSpan = document.querySelector('.usage-time');        if (usageTimeSpan) {          usageTimeSpan.textContent = this.getUsageTime();        }      });    }  },  saveTime() {    if (!this.startTime) return;        const currentSession = Math.floor((Date.now() - this.startTime) / 1000);    this.totalTime += currentSession;    localStorage.setItem(this.storageKey, this.totalTime.toString());    this.startTime = Date.now(); // Réinitialiser le startTime pour la prochaine période        console.log("Usage time saved:", this.formatTime(this.totalTime));  },  formatTime(seconds) {    if (seconds < 60) return "less than a minute";        const hours = Math.floor(seconds / 3600);    const minutes = Math.floor((seconds % 3600) / 60);        const parts = [];    if (hours > 0) {      parts.push(`${hours} hour${hours !== 1 ? 's' : ''}`);    }    if (minutes > 0 || hours === 0) {      parts.push(`${minutes} minute${minutes !== 1 ? 's' : ''}`);    }        return parts.join(' and ');  },  getUsageTime() {    if (!this.startTime) return '0 minutes';        // Calculer le temps total incluant la session courante    const currentSession = Math.floor((Date.now() - this.startTime) / 1000);    return this.formatTime(this.totalTime + currentSession);  }};// Initialiser le tracker immédiatement si le DOM est déjà chargéif (document.readyState === 'complete' || document.readyState === 'interactive') {  UsageTracker.init();} else {  document.addEventListener('DOMContentLoaded', () => UsageTracker.init());}// Script pour gérer la fonctionnalité collapsable du panneau Legend  document.addEventListener('DOMContentLoaded', function() {    const legendToggle = document.getElementById('legendToggle');    const legendContainer = legendToggle.closest('.piano-container');    const legendToggleIcon = legendToggle.querySelector('.toggle-icon');        // Définir comme fermé par défaut    let isLegendCollapsed = true;        function updateLegendCollapsed() {      if (isLegendCollapsed) {        legendContainer.classList.add('collapsed');        legendContainer.style.height = legendToggle.offsetHeight + 'px';        legendToggleIcon.textContent = '▶';      } else {        legendContainer.classList.remove('collapsed');        legendContainer.style.height = 'auto';        legendToggleIcon.textContent = '▼';      }    }        legendToggle.addEventListener('click', () => {      isLegendCollapsed = !isLegendCollapsed;      updateLegendCollapsed();    });        // Initialiser l'état    updateLegendCollapsed();  });/// KEYS   // Ajout des contrôles clavierdocument.addEventListener('keydown', function(e) {  // Éviter d'intercepter les événements lorsque l'utilisateur tape dans un champ de texte  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;    // Flèches droite et gauche pour déplacer le curseur  if (e.key === 'ArrowRight') {    moveCursor(cursorIndex + 1);    e.preventDefault();  } else if (e.key === 'ArrowLeft') {    moveCursor(cursorIndex - 1);    e.preventDefault();  }    // Espace pour Play/Stop  else if (e.key === ' ') {    if (playingSource) {      document.getElementById("stopBtn").click();    } else {      document.getElementById("playBtn").click();    }    e.preventDefault();  }    // CTRL+C ou CMD+C (MAC) pour copier en mode sélection  else if ((e.ctrlKey || e.metaKey) && e.key === 'c') {    if (isSelectionMode && selectionStart !== null && selectionEnd !== null) {      document.getElementById("copySelectionBtn").click();      e.preventDefault();    }  }    // CTRL+V ou CMD+V (MAC) pour coller  else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {    if (copiedFrames !== null) {      document.getElementById("pasteSelectionBtn").click();      e.preventDefault();    }  }    // DEL ou SUPPR pour effacer les frames sélectionnées ou toutes les frames  else if (e.key === 'Delete' || e.key === 'Backspace') {    e.preventDefault(); // Éviter de naviguer en arrière avec Backspace        if (isSelectionMode && selectionStart !== null && selectionEnd !== null) {      // En mode sélection, effacer seulement les frames sélectionnées      const frames = getCurrentFrames();      const start = Math.min(selectionStart, selectionEnd);      const end = Math.max(selectionStart, selectionEnd);            for (let i = start; i <= end; i++) {        frames[i].t = false;        frames[i].n = false;        frames[i].tone = 0;        frames[i].noise = 0;        frames[i].volume = 0;      }            notifySuccess(`Cleared all selected frames from ${start} to ${end}`);    } else if (!isSelectionMode) {      // En mode édition, demander confirmation avant d'effacer toutes les frames      if (confirm('This will clear ALL frames in current FX. Continue?')) {        const frames = getCurrentFrames();        for (let i = 0; i < frames.length; i++) {          frames[i].t = false;          frames[i].n = false;          frames[i].tone = 0;          frames[i].noise = 0;          frames[i].volume = 0;        }        notifySuccess('Cleared all frames in current FX');      }    }        renderAll();  }});  </script></body></html>